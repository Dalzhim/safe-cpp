<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2024-09-15" />
  <title>Safe C++</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.csl-block{margin-left: 1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
text-align: justify;
}
@media screen and (max-width: 30em) {
body {
margin: 1.5em;
}
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Safe C++</h1>
<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>PXXXXR0</td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2024-09-15</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      SG23<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
    </td>
  </tr>
</table>
</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#introduction" id="toc-introduction"><span class="toc-section-number">1</span> Introduction<span></span></a>
<ul>
<li><a href="#the-call-for-memory-safety" id="toc-the-call-for-memory-safety"><span class="toc-section-number">1.1</span> The call for memory
safety<span></span></a></li>
<li><a href="#extend-c-for-safety" id="toc-extend-c-for-safety"><span class="toc-section-number">1.2</span> Extend C++ for
safety<span></span></a></li>
<li><a href="#a-safe-program" id="toc-a-safe-program"><span class="toc-section-number">1.3</span> A safe
program<span></span></a></li>
<li><a href="#memory-safety-as-terms-and-conditions" id="toc-memory-safety-as-terms-and-conditions"><span class="toc-section-number">1.4</span> Memory safety as terms and
conditions<span></span></a></li>
<li><a href="#categories-of-safety" id="toc-categories-of-safety"><span class="toc-section-number">1.5</span> Categories of
safety<span></span></a></li>
</ul></li>
<li><a href="#design-overview" id="toc-design-overview"><span class="toc-section-number">2</span> Design overview<span></span></a>
<ul>
<li><a href="#the-safe-context" id="toc-the-safe-context"><span class="toc-section-number">2.1</span> The
<code class="sourceCode cpp">safe</code> context<span></span></a></li>
<li><a href="#borrow-checking" id="toc-borrow-checking"><span class="toc-section-number">2.2</span> Borrow
checking<span></span></a></li>
<li><a href="#explicit-mutation" id="toc-explicit-mutation"><span class="toc-section-number">2.3</span> Explicit
mutation<span></span></a></li>
<li><a href="#relocation-object-model" id="toc-relocation-object-model"><span class="toc-section-number">2.4</span> Relocation object
model<span></span></a></li>
<li><a href="#choice-types" id="toc-choice-types"><span class="toc-section-number">2.5</span> Choice types<span></span></a></li>
<li><a href="#interior-mutability" id="toc-interior-mutability"><span class="toc-section-number">2.6</span> Interior
mutability<span></span></a></li>
<li><a href="#send-and-sync" id="toc-send-and-sync"><span class="toc-section-number">2.7</span> Send and
sync<span></span></a></li>
</ul></li>
<li><a href="#unresolved-or-unimplemented-design-issues" id="toc-unresolved-or-unimplemented-design-issues"><span class="toc-section-number">3</span> Unresolved or unimplemented design
issues<span></span></a>
<ul>
<li><a href="#expression-outlives-constraint" id="toc-expression-outlives-constraint"><span class="toc-section-number">3.1</span>
<em>expression-outlives-constraint</em><span></span></a></li>
<li><a href="#function-parameter-ownership" id="toc-function-parameter-ownership"><span class="toc-section-number">3.2</span> Function parameter
ownership<span></span></a></li>
<li><a href="#non-static-member-functions-with-lifetimes" id="toc-non-static-member-functions-with-lifetimes"><span class="toc-section-number">3.3</span> Non-static member functions with
lifetimes<span></span></a></li>
<li><a href="#relocation-out-of-references" id="toc-relocation-out-of-references"><span class="toc-section-number">3.4</span> Relocation out of
references<span></span></a></li>
<li><a href="#a-change-of-defaults" id="toc-a-change-of-defaults"><span class="toc-section-number">3.5</span> A change of
defaults<span></span></a></li>
</ul></li>
<li><a href="#implementation-guidance" id="toc-implementation-guidance"><span class="toc-section-number">4</span> Implementation
guidance<span></span></a></li>
<li><a href="#conclusion" id="toc-conclusion"><span class="toc-section-number">5</span> Conclusion<span></span></a></li>
<li><a href="#bibliography" id="toc-bibliography"><span class="toc-section-number">6</span> References<span></span></a></li>
</ul>
</div>
<h1 data-number="1" id="introduction"><span class="header-section-number">1</span> Introduction<a href="#introduction" class="self-link"></a></h1>
<h2 data-number="1.1" id="the-call-for-memory-safety"><span class="header-section-number">1.1</span> The call for memory safety<a href="#the-call-for-memory-safety" class="self-link"></a></h2>
<p>Over the past two years, the United States Government has been
issuing warnings about memory-unsafe programming languages with
increasing urgency. Much of the country’s critical infrastructure relies
on software written in C and C++, languages which are very memory
<em>unsafe</em>, leaving these systems more vulnerable to exploits by
adversaries.</p>
<ul>
<li><p>Nov. 10, 2022 - <strong>NSA Releases Guidance on How to Protect
Against Software Memory Safety Issues</strong><span class="citation" data-cites="nsa-guidance">[<a href="https://www.nsa.gov/Press-Room/News-Highlights/Article/Article/3215760/nsa-releases-guidance-on-how-to-protect-against-software-memory-safety-issues/" role="doc-biblioref">nsa-guidance</a>]</span></p></li>
<li><p>Sep. 20, 2023 - <strong>The Urgent Need for Memory Safety in
Software Products</strong><span class="citation" data-cites="cisa-urgent">[<a href="https://www.cisa.gov/news-events/news/urgent-need-memory-safety-software-products" role="doc-biblioref">cisa-urgent</a>]</span></p></li>
<li><p>Dec. 6, 2023 - <strong>CISA Releases Joint Guide for Software
Manufacturers: The Case for Memory Safe Roadmaps</strong><span class="citation" data-cites="cisa-roadmaps">[<a href="https://www.cisa.gov/news-events/alerts/2023/12/06/cisa-releases-joint-guide-software-manufacturers-case-memory-safe-roadmaps" role="doc-biblioref">cisa-roadmaps</a>]</span></p></li>
<li><p>Feb. 26, 2024 - <strong>Future Software Should Be Memory
Safe</strong><span class="citation" data-cites="white-house">[<a href="https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/" role="doc-biblioref">white-house</a>]</span></p></li>
<li><p>May 7, 2024 - <strong>National Cybersecurity Strategy
Implementation Plan</strong><span class="citation" data-cites="ncsi-plan">[<a href="https://www.whitehouse.gov/wp-content/uploads/2024/05/NCSIP-Version-2-FINAL-May-2024.pdf" role="doc-biblioref">ncsi-plan</a>]</span></p></li>
</ul>
<p>The government papers are backed by industry research. Microsoft’s
bug telemetry reveals that 70% of its vulnerabilities would be stopped
by memory-safe programming languages.<span class="citation" data-cites="ms-vulnerabilities">[<a href="https://msrc.microsoft.com/blog/2019/07/we-need-a-safer-systems-programming-language" role="doc-biblioref">ms-vulnerabilities</a>]</span> Google’s research
has found 68% of 0day exploits are related to memory corruption.<span class="citation" data-cites="google-0day">[<a href="https://googleprojectzero.blogspot.com/p/0day.html" role="doc-biblioref">google-0day</a>]</span></p>
<ul>
<li>Mar. 4, 2024 - <strong>Secure by Design: Google’s Perspective on
Memory Safety</strong><span class="citation" data-cites="secure-by-design">[<a href="https://research.google/pubs/secure-by-design-googles-perspective-on-memory-safety/" role="doc-biblioref">secure-by-design</a>]</span></li>
</ul>
<p>Security professionals urge projects to migrate away from C++ and
adopt memory safe languages. But the scale of the problem is daunting.
C++ powers software that has generated trillions of dollars of value.
There are many veteran C++ programmers and lots of C++ code. Given how
wide-spread C++ is, what can industry really do to improve software
quality and reduce vulnerabilities? What are the options for introducing
new memory safe code into existing projects and hardening software that
already exists?</p>
<p>There’s only one popular systems-level/non-garbage collected language
that provides rigorous memory safety. That’s the Rust language.<span class="citation" data-cites="rust-language">[<a href="https://doc.rust-lang.org/book/" role="doc-biblioref">rust-language</a>]</span> But while they play in
the same space, C++ and Rust are idiomatically very different with
limited interop capability, making incremental migration from C++ to
Rust a painstaking process.</p>
<p>Rust lacks function overloading, templates, inheritance and
exceptions. C++ lacks traits, relocation and borrow checking. These
discrepancies are responsible for an impedence mismatch when interfacing
the two languages. Most code generators for inter-language bindings
aren’t able to represent features of one language in terms of the
features of another. They typically identify a number of special
vocabulary types,<span class="citation" data-cites="vocabulary-types">[<a href="https://cxx.rs/bindings.html" role="doc-biblioref">vocabulary-types</a>]</span> which have first-class
ergonomics, and limit functionality of other constructs.</p>
<p>The foreignness of Rust for career C++ developers combined with the
the friction of interop tools makes hardening C++ applications by
rewriting critical sections in Rust difficult. Why is there no
in-language solution to memory safety? <em>Why not a Safe C++?</em></p>
<h2 data-number="1.2" id="extend-c-for-safety"><span class="header-section-number">1.2</span> Extend C++ for safety<a href="#extend-c-for-safety" class="self-link"></a></h2>
<p>The goal of this proposal is to advance a superset of C++ with a
<em>rigorously safe subset</em>. Begin a new project, or take an
existing one, and start writing safe code in C++. Code in the safe
context exhibits the same strong safety guarantees as code written in
Rust.</p>
<p>Rigorous safety is a carrot-and-stick approach. The stick comes
first. The stick is what security researchers and regulators care about.
Safe C++ developers are prohibited from writing operations that may
result in lifetime safety, type safety or thread safety undefined
behaviors. Sometimes these operations are prohibited by the compiler
frontend, as is the case with pointer arithmetic. Sometimes the
operations are prohibited by static analysis in the compiler’s
middle-end; that stops use of initialized variables and use-after-free
bugs, and it’s the technology enabling the <em>ownership and
borrowing</em> safety model. The remainder of issues, like out-of-bounds
array subscripts, are averted with runtime panic and aborts.</p>
<p>The carrot is a suite of new capabilities which improve on the unsafe
ones denied to users. The affine type system makes it easier to relocate
objects without breaking type safety. Pattern matching is safe and
expressive, and interfaces with the system’s new choice types. Borrow
checking<span class="citation" data-cites="borrow-checking">[<a href="https://rust-lang.github.io/rfcs/2094-nll.html" role="doc-biblioref">borrow-checking</a>]</span> is the most
sophisticated part of the extension, providing a new reference type that
flags use-after-free and iterator invalidation defects at compile
time.</p>
<p>What are the properties we’re trying to deliver with Safe C++?</p>
<ul>
<li>A superset of C++ with a <em>safe subset</em>. Undefined behavior is
prohibited from originating in the safe subset.</li>
<li>The safe and unsafe parts of the language are clearly delineated,
and users must explicitly leave the safe context to use unsafe
operations.</li>
<li>The safe subset must remain <em>useful</em>. If we get rid of a
crucial unsafe technology, like unions and pointers, we should supply a
safe alternative, like choice types and borrows. A safe toolchain is not
useful if it’s so inexpressive you can’t get your work done.</li>
<li>The new system can’t break existing code. If you point a Safe C++
compiler at existing C++ code, that code must compile normally. Users
opt into the new safety mechanisms. Safe C++ is an extension of C++.
It’s not a new language.</li>
</ul>
<h2 data-number="1.3" id="a-safe-program"><span class="header-section-number">1.3</span> A safe program<a href="#a-safe-program" class="self-link"></a></h2>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/iterator.cxx"><strong>iterator.cxx</strong></a>
– <a href="https://godbolt.org/z/vneosEGrK">(Compiler Explorer)</a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  std2<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec <span class="op">{</span> <span class="dv">11</span>, <span class="dv">15</span>, <span class="dv">20</span> <span class="op">}</span>;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> x <span class="op">:</span> vec<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Ill-formed. mutate of vec invalidates iterator in ranged-for.</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>x <span class="op">%</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      mut vec<span class="op">.</span>push_back<span class="op">(</span>x<span class="op">)</span>;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    std2<span class="op">::</span>println<span class="op">(</span>x<span class="op">)</span>;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb1"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>$ circle iterator.cxx -I ../libsafecxx/include/</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>safety: during safety checking of int main() safe</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  borrow checking: iterator.cxx:10:11</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        mut vec.push_back(x);</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>            ^</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  mutable borrow of vec between its shared borrow and its use</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  loan created at iterator.cxx:7:15</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    for(int x : vec) {</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                ^</span></code></pre></div>
<p>Consider this demonstration of Safe C++ that catches iterator
invalidation, a kind of use-after-free bug. Let’s break it down line by
line:</p>
<p>Line 1: <code class="sourceCode cpp"><span class="pp">#</span><span class="er">feature on safety</span></code>
- Turn on the new safety-related keywords within this file. Other files
in your translation unit are unaffected. This is how Safe C++ avoids
breaking existing code–everything is opt-in, including the new keywords
and syntax. The safety feature changes the object model for function
definitions, enabling object relocation, partial and deferred
initialization. It lowers function definitions to mid-level intermediate
representation (MIR),<span class="citation" data-cites="mir">[<a href="https://rustc-dev-guide.rust-lang.org/mir/index.html" role="doc-biblioref">mir</a>]</span> on which borrow checking is
performed to flag potential use-after-free bugs on checked
references.</p>
<p>Line 2: <code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></code>
- Include the new safe containers and algorithms. Safety hardening is
about reducing your exposure to unsafe APIs. The current Standard
Library is full of unsafe APIs. The new Standard Library in namespace
<code class="sourceCode cpp">std2</code> will provide the same basic
functionality, but with containers that are lifetime-aware and type
safe.</p>
<p>Line 4: <code class="sourceCode cpp"><span class="dt">int</span> main<span class="op">()</span> safe</code>
- The new <em>safe-specifier</em> is part of a function’s type, just
like <em>noexcept-specifier</em>. To callers, the function is marked as
safe, so that it can be called from a safe context.
<code class="sourceCode cpp">main</code>’s definition starts in a safe
context, so unsafe operations such as pointer dereferences, which may
raise undefined behavior, is disallowed. Rust’s functions are safe by
default. C++’s are unsafe by default. But that’s now just a syntax
difference. Once you enter a safe context in C++ by using the
<em>safe-specifier</em>, you’re backed by the same rigorous safety
guarantees that Rust provides.</p>
<p>Line 5: <code class="sourceCode cpp">std2<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec <span class="op">{</span> <span class="dv">11</span>, <span class="dv">15</span>, <span class="dv">20</span> <span class="op">}</span>;</code>
- List initialization of a memory-safe vector. This vector is aware of
lifetime parameters, so borrow checking would extend to element types
that have lifetimes. The vector’s constructor doesn’t use <code class="sourceCode cpp">std<span class="op">::</span>initializer_list<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code>.
That type is problematic for two reasons: first, users are given
pointers into the argument data, and reading from pointers is unsafe;
second, the <code class="sourceCode cpp">std<span class="op">::</span>initializer_list</code>
<em>doesn’t own</em> its data, making relocation impossible. For these
reasons, Safe C++ introduces a <code class="sourceCode cpp">std2<span class="op">::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;</span></code>,
which can be used in a safe context and supports our ownership object
model.</p>
<p>Line 7: <code class="sourceCode cpp"><span class="cf">for</span><span class="op">(</span><span class="dt">int</span> x <span class="op">:</span> vec<span class="op">)</span></code>
- Ranged-for on the vector. The standard mechanism returns a pair of
iterators, which are pointers wrapped in classes. C++ iterators are
unsafe. They come in begin and end pairs, and don’t share common
lifetime parameters, making borrow checking them impractical. The Safe
C++ version uses slice iterators, which resemble Rust’s
<code class="sourceCode cpp">Iterator</code>.<span class="citation" data-cites="rust-iterator">[<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html" role="doc-biblioref">rust-iterator</a>]</span> These safe types use
lifetime parameters making them robust against iterator
invalidation.</p>
<p>Line 10: <code class="sourceCode cpp">mut vec<span class="op">.</span>push_back<span class="op">(</span>x<span class="op">)</span>;</code>
- Push a value onto the vector. What’s the
<code class="sourceCode cpp">mut</code> doing there? That token
establishes a <a href="#the-mutable-context"><em>mutable
context</em></a> which enables standard conversions from lvalues to
mutable borrows and references. When <code class="sourceCode cpp"><span class="op">[</span>safety<span class="op">]</span></code>
is enabled, <em>all mutations are explicit</em>. Explicit mutation lends
precision when choosing between shared borrows and mutable borrows of an
object. Rust doesn’t feature function overloading, so it will implicitly
borrow (mutably or shared) from the member function’s object. C++ of
course has function overloading, so we’ll need to be explicit in order
to get the overload we want.</p>
<p>If <code class="sourceCode cpp">main</code> checks out syntatically,
its AST is lowered to MIR, where it is borrow checked. The hidden
iterator that powers the ranged-for loop stays initialized during
execution of the loop. The <code class="sourceCode cpp">push_back</code>
<em>invalidates</em> that iterator, by mutating a place (the vector)
that the iterator has a constraint on. When the value
<code class="sourceCode cpp">x</code> is next loaded out of the
iterator, the borrow checker raises an error: <code class="sourceCode cpp"><span class="kw">mutable</span> borrow of vec between its shared borrow <span class="kw">and</span> its use</code>.
The borrow checker prevents Safe C++ from compiling a program that may
have exhibited undefined behavior. This is all done at compile time,
with no impact on your program’s size or speed.</p>
<p>This sample is only a few lines, but it introduces several new
mechanisms and types. A comprehensive effort is needed to supply a
superset of the language with a safe subset that has enough flexibility
to remain expressive.</p>
<h2 data-number="1.4" id="memory-safety-as-terms-and-conditions"><span class="header-section-number">1.4</span> Memory safety as terms and
conditions<a href="#memory-safety-as-terms-and-conditions" class="self-link"></a></h2>
<p>Memory-safe languages are predicated on a basic observation of
programmer behavior: devs try to use a library and then only consult the
docs if their first few attempts don’t seem to work. This is dangerous
to program correctness, since seeming to work is not the same as
working.</p>
<p>Many C++ functions have preconditions that are only known after
careful perusal of their documentation. Violating preconditions, which
is possible with benign-looking usage, causes undefined behavior and
opens your software to attack. <strong>Software safety and security
should not be predicated on programmers following
documentation.</strong></p>
<p>Here’s the memory safety value proposition: compiler and library
vendors make an extra effort to provide a robust environment so that
users <em>don’t have to read the docs</em>. No matter how they use the
language and library, their actions will not raise undefined behavior
and open the software to safety-related exploits. No system can guard
against all misuse, and hastily written code may have plenty of logic
bugs. But those logic bugs won’t lead to memory safety
vulnerabilities.</p>
<p>Consider an old libc function,
<code class="sourceCode cpp">std<span class="op">::</span>isprint</code>,<span class="citation" data-cites="isprint">[<a href="https://en.cppreference.com/w/cpp/string/byte/isprint" role="doc-biblioref">isprint</a>]</span> that exhibits unsafe design.
This function takes an
<code class="sourceCode cpp"><span class="dt">int</span></code>
parameter. <em>But it’s not valid to call
<code class="sourceCode cpp">std<span class="op">::</span>isprint</code>
for all int arguments</em>. The preconditions state the function be
called only with arguments between -1 and 255:</p>
<blockquote>
<p>Like all other functions from <code class="sourceCode cpp"><span class="op">&lt;</span>cctype<span class="op">&gt;</span></code>,
the behavior of
<code class="sourceCode cpp">std<span class="op">::</span>isprint</code>
is undefined if the argument’s value is neither representable as
unsigned char nor equal to EOF. To use these functions safely with plain
chars (or signed chars), the argument should first be converted to
unsigned char. Similarly, they should not be directly used with standard
algorithms when the iterator’s value type is char or signed char.
Instead, convert the value to unsigned char first.</p>
</blockquote>
<p>It feels only right, in the year 2024, to pass Unicode code points to
functions that are typed with
<code class="sourceCode cpp"><span class="dt">int</span></code> and deal
with characters. But doing so may crash your application, or worse.
While the mistake is the caller’s for not reading the documentation and
following the preconditions, it’s fair to blame the design of the API.
The safe context provided by memory safe languages prevents usage or
authoring of functions like
<code class="sourceCode cpp">std<span class="op">::</span>isprint</code>
which exhibit undefined behavior when called with invalid arguments.</p>
<p>Rust’s approach to safety<span class="citation" data-cites="safe-unsafe-meaning">[<a href="https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html" role="doc-biblioref">safe-unsafe-meaning</a>]</span> centers on defining
responsibility for enforcing preconditions. In a safe context, the user
can call safe functions without compromising program soundness. Failure
to read the docs may risk correctness, but it won’t risk undefined
behavior. When the user wants to call an unsafe function from a safe
context, they <em>explicitly take responsibility</em> for sound usage of
that unsafe function. The user writes the
<code class="sourceCode cpp">unsafe</code> token as a kind of contract:
the user has read the terms and conditions of the unsafe function and
affirms that it’s not being used in a way that violates its
preconditions.</p>
<p>Who is to blame when undefined behavior is detected–the caller or the
callee? Standard C++ does not address this. But Rust’s safety model
does: whoever typed out the <code class="sourceCode cpp">unsafe</code>
token is to blame. Safe C++ adopts the same principle. Code is divided
into unsafe and safe contexts. Unsafe operations may only occur in
unsafe contexts. Dropping from a safe context to an unsafe context
requires use of the <code class="sourceCode cpp">unsafe</code> keyword.
This leaves an artifact that makes for easy audits: reviewers search for
the <code class="sourceCode cpp">unsafe</code> keyword and focus their
attention there first. Developers checking code into the standard
library are even required to write <em>safety comments</em><span class="citation" data-cites="safety-comments">[<a href="https://std-dev-guide.rust-lang.org/policy/safety-comments.html" role="doc-biblioref">safety-comments</a>]</span> before every unsafe
block, indicating proper usage and explaining why it’s sound.</p>
<p>Consider the design of a future <code class="sourceCode cpp">std2<span class="op">::</span>isprint</code>
function. If it’s marked <code class="sourceCode cpp">safe</code>, it
must be sound for all argument values. If it’s called with an argument
that is out of its supported range, it must fail in a deterministic way:
it could return an error code, it could throw an exception or it could
panic and abort. Inside the <code class="sourceCode cpp">std2<span class="op">::</span>isprint</code>
implementation, there’s probably a lookup table with capabilities for
each supported character. If the lookup table is accessed with a slice,
an out-of-bounds access will implicitly generate a bounds check and
panic and abort on failure. If the lookup table is accessed through a
pointer, the implementer writes the
<code class="sourceCode cpp">unsafe</code> keyword, drops to the unsafe
context, tests the subscript against the range of the lookup table, and
fetches the data. The <code class="sourceCode cpp">unsafe</code> keyword
is the programmer’s oath that the subsequent unsafe operations are
sound.</p>
<p>In ISO C++, soundness holes often occur because caller and callee
don’t agree on who should enforce preconditions, so neither of them do.
In Safe C++, there’s a convention backed up by the compiler, eliminating
this confusion and improving software quality.</p>
<h2 data-number="1.5" id="categories-of-safety"><span class="header-section-number">1.5</span> Categories of safety<a href="#categories-of-safety" class="self-link"></a></h2>
<p>It’s instructive to break the memory safety problem down into four
categories. Each of these is addressed with a different language
technology.</p>
<h3 data-number="1.5.1" id="lifetime-safety"><span class="header-section-number">1.5.1</span> Lifetime safety<a href="#lifetime-safety" class="self-link"></a></h3>
<p>How do we ensure that dangling references are never used? There are
two mainstream lifetime safety technologies: garbage collection and
borrow checking. Garbage collection is simple to implement and use, but
moves object allocations to the heap, making it incompatible with manual
memory manegement. It extends object lifetimes as long as there are live
references to them, making it incompatible with C++’s RAII<span class="citation" data-cites="raii">[<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" role="doc-biblioref">raii</a>]</span> object model.</p>
<p>Borrow checking is an advanced form of live analysis. It keeps track
of the <em>live references</em> at every point in the function, and
errors when there’s a <em>conflicting action</em> on a place associated
with a live reference. For example, writing to, moving or dropping an
object with a live shared borrow will raise a borrow check error.
Pushing to a vector with a live iterator will raise an iterator
invalidation error. This system is compatible with manual memory
management and RAII, making it a good fit for C++.</p>
<p>Borrow checking a function only has to consider the body of that
function. It avoids whole-program analysis by instituting the <em>law of
exclusivity</em>. Checked references (borrows) come in two flavors:
mutable and shared, noted respectively as
<code class="sourceCode cpp">T<span class="op">^</span></code> and <code class="sourceCode cpp"><span class="kw">const</span> T<span class="op">^</span></code>.
There can be one live mutable reference to a place, or any number of
shared references to a place, but not both at once. Upholding this
principle makes it easier to reason about your program. Since the law of
exclusivity prohibits mutable aliasing, if a function is passed a
mutable reference and some shared references, you can be certain that
the function won’t have side effects that, through the mutable
reference, cause the invalidation of those shared references.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/string_view.cxx"><strong>string_view.cxx</strong></a>
– <a href="https://godbolt.org/z/6YcGP8f4W">(Compiler Explorer)</a></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std2;</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Populate the vector with views with a nice mixture of lifetimes.</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span>string_view<span class="op">&gt;</span> views <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// string_view with /static lifetime.</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  mut views<span class="op">.</span>push_back<span class="op">(</span><span class="st">&quot;From a string literal&quot;</span><span class="op">)</span>;</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// string_view with outer scope lifetime.</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  string s1 <span class="op">=</span> <span class="st">&quot;From string object 1&quot;</span>;</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  mut views<span class="op">.</span>push_back<span class="op">(</span>s1<span class="op">)</span>;</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// string_view with inner scope lifetime.</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    string s2 <span class="op">=</span> <span class="st">&quot;From string object 2&quot;</span>;</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    mut views<span class="op">.</span>push_back<span class="op">(</span>s2<span class="op">)</span>;</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// s2 goes out of scope. views now holds dangling pointers into</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// out-of-scope data. It should be ill-formed to use s2.</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Print the strings. This raises a borrow checker error, because </span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">// views depends on an expired loan on s2.</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;Printing from the outer scope:&quot;</span><span class="op">)</span>;</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span>string_view sv <span class="op">:</span> views<span class="op">)</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span>sv<span class="op">)</span>;</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>$ circle string_view.cxx -I ../libsafecxx/include/</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>safety: during safety checking of int main() safe</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  borrow checking: string_view.cxx:30:24</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    for(string_view sv : views) </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>                         ^</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  use of views depends on expired loan</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  drop of s2 between its shared borrow and its use</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  s2 declared at string_view.cxx:19:12</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>      string s2 = &quot;From string object 2&quot;; </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>             ^</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  loan created at string_view.cxx:20:25</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>      mut views.push_back(s2); </span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                          ^</span></code></pre></div>
<p>Borrow checking provides bullet-proof guarantees against lifetime
safety defects when dealing with references or views into objects with
different scopes. Take a vector of <code class="sourceCode cpp">std2<span class="op">::</span>string_view</code>.
This string view is special. It’s defined with a lifetime parameter that
establishes on the string into it refers: that string must be in scope
for all uses of the view.</p>
<p>We load the vector up with views into three different strings: a
string constant which has
<code class="sourceCode cpp"><span class="kw">static</span></code>
lifetime, a string in an outer scope and a string in an inner scope.
Printing the contents of the vector from the outer scope raises a borrow
checker error, because one of the function’s lifetime constraints is
violated: the vector depends on a loan on
<code class="sourceCode cpp">s2</code>, which is out-of-scope at the
point of use.</p>
<p>Garbage collection solves this problem in a different way:
<code class="sourceCode cpp">s1</code> and
<code class="sourceCode cpp">s2</code> are stored on the GC-managed
heap, and they’re kept in scope as long as there are live references to
them. That’s an effective system, but it’s not the right choice for C++,
where deterministic destruction order is core to the language’s
design.</p>
<h3 data-number="1.5.2" id="type-safety"><span class="header-section-number">1.5.2</span> Type safety<a href="#type-safety" class="self-link"></a></h3>
<blockquote>
<p>I call it my billion-dollar mistake. It was the invention of the null
reference in 1965. At that time, I was designing the first comprehensive
type system for references in an object oriented language (ALGOL W). My
goal was to ensure that all use of references should be absolutely safe,
with checking performed automatically by the compiler. But I couldn’t
resist the temptation to put in a null reference, simply because it was
so easy to implement. This has led to innumerable errors,
vulnerabilities, and system crashes, which have probably caused a
billion dollars of pain and damage in the last forty years.</p>
<p>– <cite>Tony Hoare</cite><span class="citation" data-cites="hoare">[<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/" role="doc-biblioref">hoare</a>]</span></p>
</blockquote>
<p>The “billion-dollar mistake” is a type safety problem. Consider <code class="sourceCode cpp">std<span class="op">::</span>unique_ptr</code>.
It has two states: engaged and disengaged. The class presents member
functions like <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">*</span></code>
and <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">-&gt;</span></code>
that are valid when the object is in the engaged state and
<em>undefined</em> when the object is disengaged.
<code class="sourceCode cpp"><span class="op">-&gt;</span></code> is the
most important API for smart pointers. Calling it when the pointer is
null? That’s your billion-dollar mistake.</p>
<p>As Hoare observes, the problem comes from conflating two different
things, a pointer to an object and an empty state, into the same type
and giving them the same interface. Smart pointers should only hold
valid pointers. Denying the null state eliminates undefined
behavior.</p>
<p>We address the type safety problem by overhauling the object model.
Safe C++ features a new kind of move: <a href="#relocation-object-model"><em>relocation</em></a>, also called
<em>destructive move</em>. This is called an <em>affine</em> or a
<em>linear</em> type system. Unless explicitly initialized, objects
start out <em>uninitialized</em>. They can’t be used in this state. When
you assign to an object, it becomes initialized. When you relocate from
an object, it’s value is moved and it’s reset to uninitialized. If you
relocate from an object inside control flow, it becomes <em>potentially
uninitialized</em>, and its destructor is conditionally executed after
reading a compiler-generated drop flag.</p>
<p><code class="sourceCode cpp">std2<span class="op">::</span>box</code>
is our version of <code class="sourceCode cpp">unique_ptr</code>. It has
no null state. There’s no default constructor. If the object is in
scope, you can dereference it without risk of undefined behavior. Why
doesn’t C++ simply introduce its own fixed
<code class="sourceCode cpp">unique_ptr</code> without a null state?
Blame C++11 move semantics.</p>
<p>How do you move objects around in C++? Use
<code class="sourceCode cpp">std<span class="op">::</span>move</code> to
select the move constructor. That moves data out of the old object,
leaving it in a default state. For smart pointers, that’s the null
state. If <code class="sourceCode cpp">unique_ptr</code> didn’t have a
null state, it couldn’t be moved in C++.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/box.cxx"><strong>box.cxx</strong></a>
– <a href="https://godbolt.org/z/aYvqoTv51">(Compiler Explorer)</a></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// p is uninitialized.</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  std2<span class="op">::</span>box<span class="op">&lt;</span>std2<span class="op">::</span>string_view<span class="op">&gt;</span> p;</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Error: p is uninitialized.</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(*</span>p<span class="op">)</span>;</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// p is definitely initialized.</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  p <span class="op">=</span> std2<span class="op">::</span>box<span class="op">&lt;</span>std2<span class="op">::</span>string_view<span class="op">&gt;(</span><span class="st">&quot;Hello Safety&quot;</span><span class="op">)</span>;</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Ok.</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(*</span>p<span class="op">)</span>;</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// p is moved into q. Now p is uninitialized again.</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> q <span class="op">=</span> rel p;</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Error: p is uninitialized.</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(*</span>p<span class="op">)</span>;</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>$ circle box.cxx -I ../libsafecxx/include/</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>safety: during safety checking of int main() safe</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  initialization analysis: box.cxx:9:12</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    println(*p);</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>             ^</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  cannot use uninitialized object p with type std2::box&lt;std2::string_view&gt;</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  initialization analysis: box.cxx:21:12</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    println(*p);</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>             ^</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  cannot use uninitialized object p with type std2::box&lt;std2::string_view&gt;</span></code></pre></div>
<p>The <em>rel-expression</em> names a local variable object or
subobject and relocates that into a new value. The old object becomes
uninitialized. Any uses of uninitialized objects generates a compiler
error. Using a null <code class="sourceCode cpp">std<span class="op">::</span>unique_ptr</code>
was undefined behavior. Using an uninitialized
<code class="sourceCode cpp">std2<span class="op">::</span>box</code> is
a compile-time error.</p>
<p>We have to reimagine our standard library in the presence of
relocation. Most kinds of resource handles include null states. These
should all be replaced by safe versions to reduce exposure to unsafe
APIs.</p>
<p>The compiler can only relocate local variables. How do we move
objects that live on the heap, or for which we only have a pointer or
reference? We need to use optional types.</p>
<p>The C++ Standard Library has an optional type, but it’s not safe to
use. The optional API is full of undefined behaviors: using <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">*</span></code>
or <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">-&gt;</span></code>
while the value is disengaged raises undefined behavior. A similar class
new to C++23, <code class="sourceCode cpp">std<span class="op">::</span>expected</code>,
exhibits the same undefined behaviors for out-of-contract uses of its
<code class="sourceCode cpp"><span class="kw">operator</span><span class="op">*</span></code>,
<code class="sourceCode cpp"><span class="kw">operator</span><span class="op">-&gt;</span></code>
and <code class="sourceCode cpp">error</code> APIs.</p>
<p>If we were to wrap the safe
<code class="sourceCode cpp">std2<span class="op">::</span>box</code> in
an <code class="sourceCode cpp">std<span class="op">::</span>optional</code>, to
represent a null state, that would be just as unsafe as using <code class="sourceCode cpp">std<span class="op">::</span>unique_ptr</code>,
since its <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">-&gt;</span></code>
is equally unsafe. We need a new <em>sum type</em> that doesn’t exhibit
the union-like defects of <code class="sourceCode cpp">std<span class="op">::</span>optional</code> and
<code class="sourceCode cpp">std<span class="op">::</span>expected</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">+&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>choice optional</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">default</span> none,</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">safety</span><span class="op">::</span><span class="at">unwrap</span><span class="op">]]</span> some<span class="op">(</span>T<span class="op">)</span>;</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> E<span class="op">&gt;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  expected<span class="op">&lt;</span>T, E<span class="op">&gt;</span> ok_or<span class="op">(</span>self, E e<span class="op">)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> match<span class="op">(</span>self<span class="op">)</span> <span class="op">-&gt;</span> expected<span class="op">&lt;</span>T, E<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>some<span class="op">(</span>t<span class="op">)</span> <span class="op">=&gt;</span> <span class="op">.</span>ok<span class="op">(</span>rel t<span class="op">)</span>;</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>none    <span class="op">=&gt;</span> <span class="op">.</span>err<span class="op">(</span>rel e<span class="op">)</span>;</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  T expect<span class="op">(</span>self, str msg<span class="op">)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> match<span class="op">(</span>self<span class="op">)</span> <span class="op">-&gt;</span> T <span class="op">{</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>some<span class="op">(</span>t<span class="op">)</span> <span class="op">=&gt;</span> rel t;</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>none    <span class="op">=&gt;</span> panic<span class="op">(</span>msg<span class="op">)</span>;</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>  T unwrap<span class="op">(</span>self<span class="op">)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> match<span class="op">(</span>self<span class="op">)</span> <span class="op">-&gt;</span> T <span class="op">{</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>some<span class="op">(</span>t<span class="op">)</span> <span class="op">=&gt;</span> rel t;</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>none    <span class="op">=&gt;</span> panic<span class="op">(</span><span class="st">&quot;{} is none&quot;</span><span class="op">.</span>format<span class="op">(</span>optional<span class="op">~</span>string<span class="op">))</span>;</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>The new <code class="sourceCode cpp">std2<span class="op">::</span>optional</code> is
a <em>choice type</em>, a first-class discriminated union, that can only
be accessed with <em>pattern matching</em>. Pattern matching makes the
union variety of type safety violations impossible: we can’t access the
wrong state of the sum type.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/match.cxx"><strong>match.cxx</strong></a>
– <a href="https://godbolt.org/z/KbGhKz78v">(Compiler Explorer)</a></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>choice Value <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  i32<span class="op">(</span><span class="dt">int</span><span class="op">)</span>,</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  f32<span class="op">(</span><span class="dt">float</span><span class="op">)</span>,</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  f64<span class="op">(</span><span class="dt">double</span><span class="op">)</span>,</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  str<span class="op">(</span>std2<span class="op">::</span>string<span class="op">)</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print<span class="op">(</span>Value val<span class="op">)</span> safe <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  match<span class="op">(</span>val<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Type safety bugs are impossible inside the pattern match.</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The alternatives listed must be exhaustive.</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>i32<span class="op">(</span>i32<span class="op">)</span> <span class="op">=&gt;</span> std2<span class="op">::</span>println<span class="op">(</span>i32<span class="op">)</span>;</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>f32<span class="op">(</span>f32<span class="op">)</span> <span class="op">=&gt;</span> std2<span class="op">::</span>println<span class="op">(</span>f32<span class="op">)</span>;</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>f64<span class="op">(</span>f64<span class="op">)</span> <span class="op">=&gt;</span> std2<span class="op">::</span>println<span class="op">(</span>f64<span class="op">)</span>;</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>str<span class="op">(</span>str<span class="op">)</span> <span class="op">=&gt;</span> std2<span class="op">::</span>println<span class="op">(</span>str<span class="op">)</span>;</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>  print<span class="op">(.</span>i32<span class="op">(</span><span class="dv">5</span><span class="op">))</span>;</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>  print<span class="op">(.</span>f32<span class="op">(</span><span class="fl">101.3</span><span class="bu">f</span><span class="op">))</span>;</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>  print<span class="op">(.</span>f64<span class="op">(</span><span class="fl">3.15159</span><span class="op">))</span>;</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>  print<span class="op">(.</span>str<span class="op">(</span><span class="st">&quot;Hello safety&quot;</span><span class="op">))</span>;</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Choice types are Safe C++’s type-safe offering. They’re just like
Rust’s enums, one of features most credited for that language’s enviable
ergonomics. Accessing members of a choice object requires testing for
the active type with a <em>match-expression</em>. If the match succeeds,
a new declaration is bound to the corresponding payload, and that
declaration is visible in the scope following the
<code class="sourceCode cpp"><span class="op">=&gt;</span></code>.</p>
<p>The compiler also performs exhaustiveness testing. Users must name
all the alternatives, or use a wildcard
<code class="sourceCode cpp">_</code> to default the unnamed ones.</p>
<p>Pattern matching and choice types aren’t just a qualify-of-life
improvement. They’re a critical part of the memory safety puzzle and all
modern languages provide them.</p>
<h3 data-number="1.5.3" id="thread-safety"><span class="header-section-number">1.5.3</span> Thread safety<a href="#thread-safety" class="self-link"></a></h3>
<p>A memory-safe language should be robust against data races to shared
mutable state. If one thread is writing to shared state, no other thread
may have access to it. C++ is not thread safe. Its synchronization
objects, such as
<code class="sourceCode cpp">std<span class="op">::</span>mutex</code>,
are opt-in. If a user reads shared mutable state from outside of a
mutex, that’s a potential data race. It’s up to users to coordinate that
the same synchronization objects are locked before accessing the same
shared mutable state.</p>
<p>A thread-safe language enforces data race safety in its type system.
Safe C++ makes it impossible, in a safe context, to produce data race
UB.</p>
<p>** Figure out thread::join consuming function issue so we can do the
thread sample.</p>
<h3 data-number="1.5.4" id="runtime-checks"><span class="header-section-number">1.5.4</span> Runtime checks<a href="#runtime-checks" class="self-link"></a></h3>
<p>One of the most common vulnerabilities is out-of-bounds access. By
default, all array-like accesses are checked in Safe C++. This includes
both arrays and slices.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/subscript_array.cxx"><strong>subscript_array.cxx</strong></a></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> array<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> index <span class="op">=</span> <span class="dv">10</span>;</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Panic on out-of-bounds array subscript.</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x <span class="op">=</span> array<span class="op">[</span>index<span class="op">]</span>;</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>and:</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/subscript_slice.cxx"><strong>subscript_slice.cxx</strong></a></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> array<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Stardard conversion from array borrow to slice borrow.</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">[</span><span class="dt">int</span>; dyn<span class="op">]^</span> slice <span class="op">=</span> <span class="op">^</span>array;</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The slice borrow is the size of 2 pointers. It contains:</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// 1. A pointer to the data.</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// 2. A size_t of the elements after the pointer.</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span><span class="dv">2</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">void</span><span class="op">*)</span> <span class="op">==</span> <span class="kw">sizeof</span> slice<span class="op">)</span>;</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Panic on out-of-bounds slice subscript.</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> index <span class="op">=</span> <span class="dv">10</span>;</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x <span class="op">=</span> slice<span class="op">[</span>index<span class="op">]</span>;</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Arithmetic is also checked and will result in panics on overflow or
underflow.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/divide_overflow.cxx"><strong>divide_overflow.cxx</strong></a></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Panic to prevent undefined behavior with int overflow.</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// This occurs regardless of safe context.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x <span class="op">=</span> INT_MIN;</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> y <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>;</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> z <span class="op">=</span> x <span class="op">/</span> y;</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 data-number="2" id="design-overview"><span class="header-section-number">2</span> Design overview<a href="#design-overview" class="self-link"></a></h1>
<h2 data-number="2.1" id="the-safe-context"><span class="header-section-number">2.1</span> The
<code class="sourceCode cpp">safe</code> context<a href="#the-safe-context" class="self-link"></a></h2>
<p>Operations in the safe context are guaranteed not to cause undefined
behavior. This protection is enforced with a number of methods. Some
operations linked to undefined behavior can’t be vetted by the frontend,
during MIR analysis or with panics at runtime. Attempting to use them in
the safe context makes the program ill-formed. These operations are:</p>
<ul>
<li>Dereference of pointers and legacy references. This may result in
use-after-free undefined behaviors. Prefer using borrows, which exhibit
lifetime safety thanks to the brorow checker.</li>
<li>Pointer offsets. Advancing a pointer past the end or the beginning
of its allocation is undefined behavior. Prefer using slices, which
include bounds information.</li>
<li>Pointer difference. Taking the difference of pointers into different
allocations is undefined behavior.</li>
<li>Pointer relational operators &lt;, &lt;=, &gt; and &gt;=. Comparing
pointers into different allocations is undefined behavior.</li>
<li>Accessing fields of unions. Legacy unions present a potential type
safety hazard. Prefer using choice types.</li>
<li>Accessing non-const objects with static storage duration. This is a
data race hazard, as different users may be writing to and reading from
the same memory simultaneously. This is even a hazard with thread_local
storage, as the law of exclusivity cannot be guaranteed within a single
thread.</li>
<li>Inline ASM. The compiler generally isn’t equipped to determine if
inline ASM is safe, so its usage in the safe context is banned.</li>
<li>Calling unsafe functions. This is banned because the unsafe function
may involve any of the above operations.</li>
</ul>
<p>Some operations are banned even in unsafe contexts. The compiler
lowers function definitions to mid-level IR (MIR) and performs
initialization analysis and borrow checking. These are data flow
analyses, and they may expose problems with your code. These issues make
the program ill-formed, regardless of the safe context:</p>
<ul>
<li>Use of uninitialized, partially initialized or potentially
initialized objects is ill-formed. This is checked by initialization
analysis.</li>
<li>A conflicting action on an overlapping place with an in-scope loan
is a borrow checker error. This reports potential use-after-free bugs.
The law of exclusivity is enforced as part of this check.</li>
<li>Free region errors. The borrow checker must confirm that lifetimes
on function parameters do not outlive the constraints defined on the
function’s declaration. This ensures that the caller and callee agree on
the lifetimes of arguments and result objects. It permits
inter-procedural live analysis without attempting very expensive
whole-program analysis.</li>
</ul>
<p>Some operations are potentially unsound, but can be checked at
runtime. They are checked for soundness, and if they fail, the program
panics and aborts. There are there cases of this:</p>
<ul>
<li>Integer division by 0.</li>
<li>Integer division of INT_MIN by -1.</li>
<li>Out of bounds subscripting an array or slice.</li>
</ul>
<h3 data-number="2.1.1" id="safe-specifier"><span class="header-section-number">2.1.1</span> <em>safe-specifier</em><a href="#safe-specifier" class="self-link"></a></h3>
<p>Similar to the <em>noexcept-specifier</em>, function types and
declarations may be marked with a <em>safe-specifier</em>. Place this
after the <em>noexcept-specifier</em>. Types and functions without the
<em>noexcept-specifer</em> are assumed to be potentially throwing.
Similarly, types and functions without the <em>safe-specifier</em> are
assumed to be unsafe.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// `safe` is part of the function type.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> F1 <span class="op">=</span> <span class="dt">void</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span>;</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> F2 <span class="op">=</span> <span class="dt">void</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> safe;</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> F3 <span class="op">=</span> <span class="dt">void</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> F4 <span class="op">=</span> <span class="dt">void</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="kw">noexcept</span> safe;</span></code></pre></div>
<p>As with
<code class="sourceCode cpp"><span class="kw">noexcept</span></code>,
<code class="sourceCode cpp">safe</code> is part of the function’s type,
so types with different <em>safe-specifiers</em> always compare
differently.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">// `safe` is part of the function type.</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>F1 <span class="op">!=</span> F2<span class="op">)</span>;</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>F3 <span class="op">!=</span> F4<span class="op">)</span>;</span></code></pre></div>
<p>As with <em>noexcept-specifier</em>, the safeness of a function’s
type can be stripped when converting function pointers. It’s unsound to
add a <em>safe-specifier</em> during conversion, so that’s prohibit. But
it’s okay to strip <code class="sourceCode cpp">safe</code>, just as
it’s permitted to strip
<code class="sourceCode cpp"><span class="kw">noexcept</span></code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">// You can strip off `safe` in function pointers.</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_convertible_v<span class="op">&lt;</span>F2<span class="op">*</span>, F1<span class="op">*&gt;)</span>;</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_convertible_v<span class="op">&lt;</span>F4<span class="op">*</span>, F3<span class="op">*&gt;)</span>;</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co">// You can strip off both `noexcept` and `safe`.</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_convertible_v<span class="op">&lt;</span>F4<span class="op">*</span>, F1<span class="op">*&gt;)</span>;</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co">// You can&#39;t add safe. That&#39;s unsafe.</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(!</span>std<span class="op">::</span>is_convertible_v<span class="op">&lt;</span>F1<span class="op">*</span>, F2<span class="op">*&gt;)</span>;</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(!</span>std<span class="op">::</span>is_convertible_v<span class="op">&lt;</span>F3<span class="op">*</span>, F4<span class="op">*&gt;)</span>;</span></code></pre></div>
<p>Declaring functions with value-dependent <em>safe-specifiers</em> is
supported. This follows dependent <em>noexcept-specifiers</em>, allowing
users to use the <em>safe-operator</em> to query the safeness of an
expression and reflect that in the <em>safe-specifier</em>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">bool</span> IsSafe<span class="op">&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo_t <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Value-dependent safe-specifier. Set to the template parameter.</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f1<span class="op">()</span> safe<span class="op">(</span>IsSafe<span class="op">)</span>;</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Set f2&#39;s safe specifier to the safeness of arg.func().</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f2<span class="op">(</span>T arg<span class="op">)</span> safe<span class="op">(</span>safe<span class="op">(</span>arg<span class="op">.</span>func<span class="op">()))</span>;</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<h3 data-number="2.1.2" id="safe-operator"><span class="header-section-number">2.1.2</span> <em>safe-operator</em><a href="#safe-operator" class="self-link"></a></h3>
<p>You can query the safeness of an expression in an unevaluated context
with the <em>safe-operator</em>. It’s analagous to the existing
<em>noexcept-operator</em>. This is very useful when paired with
<em>requires-clause</em>, as it lets you constrain inputs based on the
safeness of a callable.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/safe.cxx"><strong>safe.cxx</strong></a></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> F, <span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> spawn<span class="op">(</span>F f, Args<span class="op">...</span> args<span class="op">)</span> safe <span class="kw">requires</span><span class="op">(</span>safe<span class="op">(</span>f<span class="op">(</span>args<span class="op">...)))</span>;</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Foo <span class="op">{</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The int overload is safe.</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">const</span> self<span class="op">^</span>, <span class="dt">int</span><span class="op">)</span> safe;</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The double overload is unsafe.</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">const</span> self<span class="op">^</span>, <span class="dt">double</span><span class="op">)</span>;</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>  Foo obj <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>  spawn<span class="op">(</span>obj, <span class="dv">1</span><span class="op">)</span>;   <span class="co">// OK</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>  spawn<span class="op">(</span>obj, <span class="fl">1.1</span><span class="op">)</span>; <span class="co">// Ill-formed. Fails requires-clause.</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>$ circle safe.cxx</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>error: safe.cxx:17:8</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  spawn(obj, 1.1); // Ill-formed. Fails requires-clause.</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>       ^</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>error during overload resolution for spawn</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  instantiation: safe.cxx:4:6</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  void spawn(F f, Args... args) safe requires(safe(f(args...)));</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>       ^</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  template arguments: [</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    F = Foo</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>      class Foo declared at safe.cxx:6:1</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    Args#0 = double</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    constraint: safe.cxx:4:45</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    void spawn(F f, Args... args) safe requires(safe(f(args...)));</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>                                                ^</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    spawn fails requires-clause (safe(f(args...)))</span></code></pre></div>
<p>Consider a <code class="sourceCode cpp">spawn</code> function that
takes a callable <code class="sourceCode cpp">f</code> and a set of
arguments <code class="sourceCode cpp">args</code>. The function is
marked <code class="sourceCode cpp">safe</code>. Transitively, the
callable, when invoked with the provided arguments, must also be a safe
operation. But we can’t stipulate
<code class="sourceCode cpp">safe</code> on the type
<code class="sourceCode cpp">F</code>, because it may not be a function
type. In this example it’s a class with two overloaded call
operators.</p>
<p>When the user provides an integer argument, the
<em>requires-clause</em> substitutes to <code class="sourceCode cpp">safe<span class="op">(</span>f<span class="op">(</span><span class="dv">1</span><span class="op">))</span></code>,
which is true, because the best viable candidate for the function call
is <code class="sourceCode cpp"><span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">const</span> self<span class="op">^</span>, <span class="dt">int</span><span class="op">)</span> safe;</code>.
That’s a safe function.</p>
<p>When the user provides a floating-point argument, the
<em>requires-clause</em> substitutes to <code class="sourceCode cpp">safe<span class="op">(</span>f<span class="op">(</span><span class="fl">1.1</span><span class="op">))</span></code>,
which is false, because the best viable candidate is <code class="sourceCode cpp"><span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">const</span> self<span class="op">^</span>, <span class="dt">double</span><span class="op">)</span>;</code>.
That’s not a safe function.</p>
<p>These kind of constraints are idiomatic in C++ but not supported in
Rust, because that language uses early-checked traits to implement
generics.</p>
<h3 data-number="2.1.3" id="unsafe-block"><span class="header-section-number">2.1.3</span> <em>unsafe-block</em><a href="#unsafe-block" class="self-link"></a></h3>
<p>The <code class="sourceCode cpp">unsafe</code> token escapes the safe
context and admits operations for which soundness cannot be guaranteed
by the compiler. The primary unsafe escape is the <em>unsafe-block</em>.
At the statement level, write <code class="sourceCode cpp">unsafe <span class="op">{</span> <span class="op">}</span></code>
and put the unsafe operations inside the braces. Unlike in Rust,
<em>unsafe-blocks</em> do <em>not</em> open new lexical scopes.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> func<span class="op">(</span><span class="kw">const</span> <span class="dt">int</span><span class="op">*</span> p<span class="op">)</span> safe <span class="op">{</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Most pointer operations are unsafe. Use unsafe-block to perform them in</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// a safe function.</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Pointer offset is unsafe.</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  unsafe <span class="op">{</span> <span class="op">++</span>p; <span class="op">}</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Put multiple statements in an unsafe-block.</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  unsafe <span class="op">{</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Pointer difference is unsafe.</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">ptrdiff_t</span> diff <span class="op">=</span> p <span class="op">-</span> p;</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// unsafe-blocks do not open lexical scopes. Declarations will be</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// visible below.</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> p<span class="op">[</span><span class="dv">4</span><span class="op">]</span>;</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Can use unsafe-block like compound-statement inside control flow.</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span><span class="op">(</span>x <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> unsafe <span class="op">{</span> <span class="cf">return</span> p<span class="op">[</span><span class="dv">5</span><span class="op">]</span>; <span class="op">}</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x;</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Unsafe blocks are supported in different forms in a several
places:</p>
<ul>
<li>Before subobject <em>mem-initializer</em>.</li>
<li>Before <em>condition</em> expressions.</li>
<li>Before <em>match-body</em> in a <em>match-clause</em>.</li>
</ul>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Unsafe function.</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> pred<span class="op">()</span>;</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Foo <span class="op">{</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Support unsafe before subobject initializers.</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  Foo<span class="op">()</span> <span class="op">:</span> unsafe b<span class="op">(</span>pred<span class="op">())</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> b;</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Support unsafe before conditions.</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span><span class="op">(</span>unsafe pred<span class="op">())</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span><span class="op">(</span>unsafe pred<span class="op">())</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x <span class="op">=</span> match<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Support unsafe after the =&gt; in a match-clause.</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=&gt;</span> unsafe pred<span class="op">()</span>;</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In all uses, <code class="sourceCode cpp">unsafe</code> represents an
auditable token where the user expressly takes responsibility for sound
execution.</p>
<h3 data-number="2.1.4" id="the-unsafe-type-qualifier"><span class="header-section-number">2.1.4</span> The
<code class="sourceCode cpp">unsafe</code> type qualifier<a href="#the-unsafe-type-qualifier" class="self-link"></a></h3>
<p>The Rust ecosystem was built from the bottom-up prioritizing safe
code. Consequently, there’s so little unsafe code that the
<em>unsafe-block</em> is generally sufficient for interfacing with it.
By contrast, there are many billions of lines of unsafe C++ in the wild.
The <em>unsafe-block</em> isn’t powerful enough to interface our safe
and unsafe assets, as we’d be writing <em>unsafe-blocks</em> everywhere,
making a noisy mess. Worse, we’d be unable to use unsafe types from safe
function templates, since the template definition wouldn’t know it was
dealing with unsafe template parameters. Because of the ecosystem
difference, Rust does not provide guidance for this problem, and we’re
left to our own devices.</p>
<p><strong>Safe C++’s answer to safe/unsafe interoperability is to make
safeness part of the type system.</strong></p>
<p>C++ has
<code class="sourceCode cpp"><span class="kw">const</span></code> and
<code class="sourceCode cpp"><span class="kw">volatile</span></code>
type qualifiers. C++ compilers also support the
<code class="sourceCode cpp">_Atomic</code> type qualifier, through C11.
Safe C++ adds the <code class="sourceCode cpp">unsafe</code> type
qualifier. Declare an object or data member with the unsafe qualifier
and use it freely <em>even in safe contexts</em>. The
<code class="sourceCode cpp">unsafe</code> token means the same thing
here as it does with <em>unsafe-blocks</em>: the programmer is declaring
responsibility for upholding the conditions of the object. Blame lies
with the <code class="sourceCode cpp">unsafe</code> wielder.</p>
<p>Naming an unsafe object yields an lvalue expression of the unsafe
type. What are the effects of the unsafe qualifier on an expression?</p>
<ul>
<li>Calling unsafe member functions on unsafe-qualified objects is
permitted.</li>
<li>Calling unsafe functions where a function argument is
unsafe-qualified is permitted.</li>
<li>Unsafe constructors may initialize unsafe types.</li>
</ul>
<p>Calling unsafe member functions on expressions with unsafe types is
permitted in the unsafe context. Calling initializers of unsafe types is
also permitted. In fact, these operations on unsafe types are “safe” for
the purpose of <em>safe-operator</em>.</p>
<p>Expressions carry noexcept and safe information which is outside of
the type’s expression; this information is moved transitively between
subexpressions and feeds the <em>noexcept-</em> and
<em>safe-operator</em>. Why make unsafe a type qualifier, which
represents a significant change to the type system, rather than some
other kind of property of an object or member declaration, propagate it
like the noexcept and safe flags?</p>
<p>The answer is that template specialization works on types and it
doesn’t work on these other kinds of properties. A template argument
with an unsafe qualifier instantiates a template with an unsafe
qualifier on the corresponding template parameter. The unsafe qualifier
drills through templates in a way that other language entities
don’t.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/unsafe2.cxx"><strong>unsafe2.cxx</strong></a>
– <a href="https://godbolt.org/z/1E9Y7rcbx">(Compiler Explorer)</a></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Requires unsafe type specifier because std::string&#39;s dtor is unsafe.</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  std2<span class="op">::</span>vector<span class="op">&lt;</span>unsafe std<span class="op">::</span>string<span class="op">&gt;</span> vec <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Construct an std::string from a const char* (unsafe)</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Pass by relocation (unsafe)</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  mut vec<span class="op">.</span>push_back<span class="op">(</span><span class="st">&quot;Hello unsafe type qualifier!&quot;</span><span class="op">)</span>;</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Pass const char*</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Construct inside emplace_back (unsafe)</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>  mut vec<span class="op">.</span>push_back<span class="op">(</span><span class="st">&quot;I integrate with legacy types&quot;</span><span class="op">)</span>;</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Append Bar to the end of Foo (unsafe)</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>  mut vec<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">+=</span> vec<span class="op">[</span><span class="dv">1</span><span class="op">]</span>;</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>  std2<span class="op">::</span>println<span class="op">(</span>vec<span class="op">[</span><span class="dv">0</span><span class="op">])</span>;</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We want to use the new memory-safe vector with the legacy string
type. The new vector is borrow checked, eliminating use-after-free and
iterator invalidation defects. It presents a safe interface. But the old
string is pre-safety. All its member functions are unsafe. If we want to
specialize the new vector on the old string, we need to mark it
<code class="sourceCode cpp">unsafe</code>.</p>
<p>The unsafe type qualifier propagates through the instantiated vector.
The expressions returned through the <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">[]</span></code>
accessor are unsafe qualified, so we can call unsafe member functions on
the string, even in main’s safe context.</p>
<p>Let’s simplify the example above and study it in detail.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/unsafe3.cxx"><strong>unsafe3.cxx</strong></a></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">+&gt;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec <span class="op">{</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  Vec<span class="op">()</span> safe;</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> push_back<span class="op">(</span>self<span class="op">^</span>, T obj<span class="op">)</span> safe;</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> String <span class="op">{</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>  String<span class="op">(</span><span class="kw">const</span> <span class="dt">char</span><span class="op">*)</span>; <span class="co">// Unsafe ctor.</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Vec has a safe constructor.</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>  Vec<span class="op">&lt;</span>unsafe String<span class="op">&gt;</span> vec <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// void Vec&lt;unsafe String&gt;::push_back(self^, unsafe String) safe;</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Copy initialization of the `unsafe String` function parameter is</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">// permitted.</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>  mut vec<span class="op">.</span>push_back<span class="op">(</span><span class="st">&quot;A string&quot;</span><span class="op">)</span>;</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In this example, the unsafe String constructor is called in the safe
main function. That’s permitted because substitution of
<code class="sourceCode cpp">unsafe String</code> into Vec’s template
parameter creates a push_back specialization with an
<code class="sourceCode cpp">unsafe String</code> function parameter.
Safe C++ allows unsafe constructors to initialize unsafe types in an
unsafe context.</p>
<p>Permitting unsafe operations with unsafe specialization is far
preferable to using conditional <em>unsafe-specifiers</em> on the class
template’s member functions. We want the vector to keep its safe
interface so that it can be used by safe callers. This device allows
member functions to remain safe without resorting to
<em>unsafe-blocks</em> in the implementations. There’s a single use of
the <code class="sourceCode cpp">unsafe</code> token, which makes for
simple audits during code review.</p>
<p>Placing the unsafe token on the <em>template-argument-list</em>,
where the class template gets used, is also far safer than enclosing
operations on the template parameter type in <em>unsafe-blocks</em>
inside the template. In the former case, the user of the container can
read its preconditions and swear that the precondidions are met. In the
latter case, the template isn’t able to make any statements about
properly using the template type, because it doesn’t know what that type
is. The <code class="sourceCode cpp">unsafe</code> token should go with
the caller, not the callee.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/unsafe4.cxx"><strong>unsafe4.cxx</strong></a></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">+&gt;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec <span class="op">{</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  Vec<span class="op">()</span> safe;</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> push_back<span class="op">(</span>self<span class="op">^</span>, T obj<span class="op">)</span> safe;</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> String <span class="op">{</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>  String<span class="op">(</span><span class="kw">const</span> <span class="dt">char</span><span class="op">*)</span>; <span class="co">// Unsafe ctor.</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Vec has a safe constructor.</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>  Vec<span class="op">&lt;</span>unsafe String<span class="op">&gt;</span> vec <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// void Vec&lt;unsafe String&gt;::push_back(self^, unsafe String) safe;</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Copy initialization of the `unsafe String` function parameter is</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">// permitted.</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>  mut vec<span class="op">.</span>push_back<span class="op">(</span><span class="st">&quot;A string&quot;</span><span class="op">)</span>;</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>$ circle unsafe4.cxx</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>error: unsafe4.cxx:20:27</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  mut vec.push_back(String(&quot;A string&quot;));</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>                          ^</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>cannot call unsafe constructor String::String(const char*) in safe context</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>see declaration at unsafe4.cxx:10:3</span></code></pre></div>
<p>This code is ill-formed. We’ve established that it’s permitted to
copy initialize into the push_back call, since its function parameter is
<code class="sourceCode cpp">unsafe String</code>, but direct
initialization of <code class="sourceCode cpp">String</code> is not
allowed. The constructor chosen for direct initialization is unsafe, but
the type it’s initializing is not. The compiler is right to reject this
program because the user is plainly calling an unsafe constructor in a
safe context, without a mitigating <em>unsafe-block</em> or unsafe
qualifier.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/unsafe5.cxx"><strong>unsafe5.cxx</strong></a></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">+&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec <span class="op">{</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  Vec<span class="op">()</span> safe;</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> push_back<span class="op">(</span>self<span class="op">^</span>, T obj<span class="op">)</span> safe;</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> emplace_back<span class="op">(</span>self<span class="op">^</span>, Ts<span class="op">...</span> obj<span class="op">)</span> safe <span class="op">{</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Direct initialization with the String(const char*) ctor.</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This compiles, because T is unsafe-qualified.</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    self<span class="op">.</span>push_back<span class="op">(</span>T<span class="op">(</span>rel obj<span class="op">...))</span>;</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> String <span class="op">{</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>  String<span class="op">(</span><span class="kw">const</span> <span class="dt">char</span><span class="op">*)</span>; <span class="co">// Unsafe ctor.</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Vec has a safe constructor.</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>  Vec<span class="op">&lt;</span>unsafe String<span class="op">&gt;</span> vec <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">// void Vec&lt;unsafe String&gt;::emplace_back(self^, const char*) safe;</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>  mut vec<span class="op">.</span>emplace_back<span class="op">(</span><span class="st">&quot;A string&quot;</span><span class="op">)</span>;</span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This program is well-formed. As with the previous example, there’s a
direct initialization of a String object using its unsafe constructor.
But this time it’s allowed, because the type being initialized is
<code class="sourceCode cpp">T</code>, which is substituted with
<code class="sourceCode cpp">unsafe String</code>: unsafe constructors
are permitted to initialize unsafe types.</p>
<p>The <a href="#the-unsafe-type-qualifier">unsafe type qualifier</a> is
a powerful mechanism for incorporating legacy code into new, safe
templates. But propagating the qualifier through all template parameters
may be too permissive. C++ templates won’t be expecting the
<code class="sourceCode cpp">unsafe</code> qualifier, and it may break
dependencies. Functions that are explicitly instantiated won’t have
<code class="sourceCode cpp">unsafe</code> instantiations, and that
would cause link errors. It may be prudent to get some usage experience,
and limit this type qualifier to being deduced only by type template
parameters with a certain token, eg <code class="sourceCode cpp"><span class="kw">typename</span> T<span class="op">?</span></code>.
That way, <code class="sourceCode cpp"><span class="kw">typename</span> T<span class="op">+?</span></code>
would become a common incantation for containers: create template
lifetime parameters for this template parameter <em>and</em> deduce the
unsafe qualifier for it.</p>
<p>To be more accommodating when mixing unsafe with safe code, the
unsafe qualifier has very liberal transitive properties. A function
invoked with an unsafe-qualified object or argument, or a constructor
that initializes an unsafe type, are <em>exempted calls</em>. When
performing overload resolution for exempted calls, function parameters
of candidates become unsafe type qualified. This permits copy
initialization of function arguments into parameter types when any
argument is unsafe qualified. The intent is to make deployment of the
<code class="sourceCode cpp">unsafe</code> token more strategic: use it
less often but make it more impactful. It’s not helpful to dilute its
potency with many trivial <em>unsafe-block</em> operations.</p>
<h3 data-number="2.1.5" id="unsafe-subscripts"><span class="header-section-number">2.1.5</span> unsafe subscripts<a href="#unsafe-subscripts" class="self-link"></a></h3>
<p>There’s one more prominent use of the
<code class="sourceCode cpp">unsafe</code> token. It’ll suppress runtime
bounds checks during subscript operations on both builtin and
user-defined types. For applications where nanoseconds matter,
developers may want to forego runtime bounds checking. In Safe C++, this
is exceptionally easy. Just write
<code class="sourceCode cpp">; unsafe</code> in your array, slice or
vector subscript.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/unsafe_bounds.cxx"><strong>unsafe_bounds.cxx</strong></a>
– <a href="https://godbolt.org/z/9xajqhrvc">(Compiler Explorer)</a></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> subscript_array<span class="op">([</span><span class="dt">int</span>; <span class="dv">10</span><span class="op">]</span> array, <span class="dt">size_t</span> i, <span class="dt">size_t</span> j<span class="op">)</span> safe <span class="op">{</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  array<span class="op">[</span>i; unsafe<span class="op">]</span> <span class="op">+=</span> array<span class="op">[</span>j; unsafe<span class="op">]</span>;</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> subscript_slice<span class="op">([</span><span class="dt">int</span>; dyn<span class="op">]^</span> slice, <span class="dt">size_t</span> i, <span class="dt">size_t</span> j<span class="op">)</span> safe <span class="op">{</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  slice<span class="op">[</span>i; unsafe<span class="op">]</span> <span class="op">+=</span> slice<span class="op">[</span>j; unsafe<span class="op">]</span>;</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> subscript_vector<span class="op">(</span>std2<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec, <span class="dt">size_t</span> i, <span class="dt">size_t</span> j<span class="op">)</span> safe <span class="op">{</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>  mut vec<span class="op">[</span>i; unsafe<span class="op">]</span> <span class="op">+=</span> vec<span class="op">[</span>j; unsafe<span class="op">]</span>;</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The unsafe subscript cleary indicates that runtime bounds checks is
relaxed, while keeping a consistent syntax with ordinary checked
subscripts. It doesn’t expose any other operations, including
preparation of the subscript index, to an unsafe context. The use of the
<code class="sourceCode cpp">unsafe</code> token is the programmer’s way
of taking responsibility for correct behavior. If something goes wrong,
you know who to blame.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/unsafe_bounds.rs"><strong>unsafe_bounds.rs</strong></a></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> subscript_array(<span class="kw">mut</span> array<span class="op">:</span> [<span class="dt">i32</span><span class="op">;</span> <span class="dv">10</span>]<span class="op">,</span> i<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> j<span class="op">:</span> <span class="dt">usize</span>) <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">*</span>array<span class="op">.</span>get_unchecked_mut(i) <span class="op">+=</span> <span class="op">*</span>array<span class="op">.</span>get_unchecked(j)<span class="op">;</span> <span class="op">}</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> subcript_slice(slice<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> [<span class="dt">i32</span>]<span class="op">,</span> i<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> j<span class="op">:</span> <span class="dt">usize</span>) <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">*</span>slice<span class="op">.</span>get_unchecked_mut(i) <span class="op">+=</span> <span class="op">*</span>slice<span class="op">.</span>get_unchecked(j)<span class="op">;</span> <span class="op">}</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> subscript_vector(<span class="kw">mut</span> vec<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;,</span> i<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> j<span class="op">:</span> <span class="dt">usize</span>) <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">*</span>vec<span class="op">.</span>get_unchecked_mut(i) <span class="op">+=</span> <span class="op">*</span>vec<span class="op">.</span>get_unchecked(j)<span class="op">;</span> <span class="op">}</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Rust’s unchecked subscript story is not elegant. You have to use the
separately named functions
<code class="sourceCode cpp">get_unchecked</code> and
<code class="sourceCode cpp">get_unchecked_mut</code> which are
associated with arrays, slices and vectors using traits. These are
unsafe functions, so your calls have to be wrapped in
<em>unsafe-blocks</em>. That exposes other operations to the unsafe
context. Since we’re invoking functions directly, as opposed to using
the <code class="sourceCode cpp"><span class="op">[]</span></code>
operator, we don’t get automatic dereference of the returned
borrows.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">+&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> vector</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  value_type<span class="op">^</span> <span class="kw">operator</span><span class="op">[](</span>self<span class="op">^</span>, size_type i<span class="op">)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> self<span class="op">.</span>size<span class="op">())</span> panic_bounds<span class="op">(</span><span class="st">&quot;vector subscript is out-of-bounds&quot;</span><span class="op">)</span>;</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    unsafe <span class="op">{</span> <span class="cf">return</span> <span class="op">^</span>self<span class="op">.</span>data<span class="op">()[</span>i<span class="op">]</span>; <span class="op">}</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>  value_type<span class="op">^</span> <span class="kw">operator</span><span class="op">[](</span>self<span class="op">^</span>, size_type i, no_runtime_check<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">^</span>self<span class="op">.</span>data<span class="op">()[</span>i<span class="op">]</span>;</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> value_type<span class="op">^</span> <span class="kw">operator</span><span class="op">[](</span><span class="kw">const</span> self<span class="op">^</span>, size_type i<span class="op">)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> self<span class="op">.</span>size<span class="op">())</span> panic_bounds<span class="op">(</span><span class="st">&quot;vector subscript is out-of-bounds&quot;</span><span class="op">)</span>;</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    unsafe <span class="op">{</span> <span class="cf">return</span> <span class="op">^</span>self<span class="op">.</span>data<span class="op">()[</span>i<span class="op">]</span>; <span class="op">}</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> value_type<span class="op">^</span> <span class="kw">operator</span><span class="op">[](</span><span class="kw">const</span> self<span class="op">^</span>, size_type i, no_runtime_check<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">^</span>self<span class="op">.</span>data<span class="op">()[</span>i<span class="op">]</span>;</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>The unsafe subscript works with user-defined types by introducing a
new library type <code class="sourceCode cpp">std2<span class="op">::</span>no_runtime_check</code>.
Use this as last parameter in a user-defined <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">[]</span></code>
call, including multi-dimensional subscript operators, to enable unsafe
subscript binding. The compiler default-initializes a no_runtime_check
and attempts to pass that during overload resolution.
<code class="sourceCode cpp">no_runtime_check</code> overloads are
<em>unsafe functions</em>, as they aren’t sound for all valid inputs.
However, when invoked as part of an unsafe subscript, they can still be
used in safe contexts. That’s because the user wrote out the
<code class="sourceCode cpp">unsafe</code> at the point of use,
exempting this function call from the unsafe check.</p>
<h2 data-number="2.2" id="borrow-checking"><span class="header-section-number">2.2</span> Borrow checking<a href="#borrow-checking" class="self-link"></a></h2>
<p>There’s one widely deployed solution to lifetime safety: garbage
collection. In GC, the scope of an object is extended as long as there
are live references to it. When there are no more live references, the
system is free to destroy the object. Most memory safe languages use
tracing garbage collection.<span class="citation" data-cites="tracing-gc">[<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" role="doc-biblioref">tracing-gc</a>]</span> Some, like Python and Swift,
use automatic reference counting,<span class="citation" data-cites="arc">[<a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/" role="doc-biblioref">arc</a>]</span> a flavor of garbage collection with
different tradeoffs.</p>
<p>Garbage collection requires storing objects on the <em>heap</em>. But
C++ is about <em>manual memory management</em>. We need to track
references to objects on the <em>stack</em> as well as on the heap. As
the stack unwinds objects are destroyed. We can’t extend their duration
beyond their lexical scopes. Borrow checking<span class="citation" data-cites="borrow-checking">[<a href="https://rust-lang.github.io/rfcs/2094-nll.html" role="doc-biblioref">borrow-checking</a>]</span> is a kind of
compile-time analysis that prevents using a reference after an object
has gone out of scope. That is, it solves use-after-free and iterator
invalidation bugs.</p>
<h3 data-number="2.2.1" id="use-after-free"><span class="header-section-number">2.2.1</span> Use-after-free<a href="#use-after-free" class="self-link"></a></h3>
<p><code class="sourceCode cpp">std<span class="op">::</span>string_view</code>
was added to C++ as a safer alternatives to passing character pointers
around. Unfortunately, its rvalue reference constructorn is so
dangerously designed that its reported to <em>encourage</em>
use-after-free bugs.<span class="citation" data-cites="string-view-use-after-free">[<a href="https://github.com/isocpp/CppCoreGuidelines/issues/1038" role="doc-biblioref">string-view-use-after-free</a>]</span></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string_view&gt;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>string s <span class="op">=</span> <span class="st">&quot;Hellooooooooooooooo &quot;</span>;</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>string_view sv <span class="op">=</span> s <span class="op">+</span> <span class="st">&quot;World</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> sv;</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>$ circle string_view.cxx</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>$ ./string_view</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>@.ooo World</span></code></pre></div>
<p><code class="sourceCode cpp">s</code> is initialized with a long
string, which makes it use storage on the heap. The <code class="sourceCode cpp">string<span class="op">::</span><span class="kw">operator</span><span class="op">+</span></code>
returns a temporary
<code class="sourceCode cpp">std<span class="op">::</span>string</code>
object, also with the data stored on the heap.
<code class="sourceCode cpp">sv</code> is initialized by calling the
<code class="sourceCode cpp">string<span class="op">::</span><span class="kw">operator</span> string_view<span class="op">()</span></code>
conversion function on the temporary. The temporary string goes out of
scope at the end of that statement, its storage is returned to the heap,
and the user prints a string view with dangling pointers.</p>
<p>This design is full of sharp edges. It should not have made the ISO
Standard. But C++ didn’t have great alternatives, since it lacks borrow
checking, which is the technology that flags these problems.</p>
<p>Safe C++ allows us to author lifetime-aware
<code class="sourceCode cpp">string_view</code> types that provide
memory safety. The compiler prohibits uses of dangling views.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  std2<span class="op">::</span>string s <span class="op">=</span> <span class="st">&quot;Hellooooooooooooooo &quot;</span>;</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  std2<span class="op">::</span>string_view sv <span class="op">=</span> s <span class="op">+</span> <span class="st">&quot;World</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span>sv<span class="op">)</span>;</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>$ circle str0.cxx</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>safety: str0.cxx:7:11</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  println(sv);</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>          ^</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>use of sv depends on expired loan</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>drop of temporary std2::basic_string&lt;char, std2::allocator&lt;char&gt;&gt; between its shared borrow and its use</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>loan created at str0.cxx:6:28</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  std2::string_view sv = s + &quot;World\n&quot;;</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                           ^</span></code></pre></div>
<p>The compiler flags the use of the dangling view, <code class="sourceCode cpp">println<span class="op">(</span>sv<span class="op">)</span></code>.
It marks the invalidating action, the drop of the temporary string. And
it indicates where the loan was created, which is the conversion to
<code class="sourceCode cpp">string_view</code> right after the string
concatenation. See the <a href="#lifetime-error-reporting">error
reporting</a> section for details on lifetime diagnostics.</p>
<p>The borrow checking mechanics is visible by examining the declaration
of the conversion function on
<code class="sourceCode cpp">std2<span class="op">::</span>string</code>
which produces a <code class="sourceCode cpp">std2<span class="op">::</span>string_view</code>.
This is gets called during sv’s initialization.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> basic_string_view<span class="op">/(</span>a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  basic_string_view<span class="op">(</span><span class="kw">const</span> <span class="op">[</span>value_type; dyn<span class="op">]^/</span>a str, no_utf_check<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span> p_<span class="op">(</span>str<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> basic_string <span class="op">{</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>  basic_string_view<span class="op">&lt;</span>value_type<span class="op">&gt;</span> str<span class="op">(</span>self <span class="kw">const</span><span class="op">^)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> no_utf_check <span class="op">=</span> <span class="kw">typename</span> basic_string_view<span class="op">&lt;</span>value_type<span class="op">&gt;::</span>no_utf_check;</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    unsafe <span class="op">{</span> <span class="cf">return</span> basic_string_view<span class="op">&lt;</span>value_type<span class="op">&gt;(</span>self<span class="op">.</span>slice<span class="op">()</span>, no_utf_check<span class="op">{})</span>; <span class="op">}</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span> basic_string_view<span class="op">&lt;</span>value_type<span class="op">&gt;(</span>self <span class="kw">const</span><span class="op">^)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> self<span class="op">.</span>str<span class="op">()</span>;</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>String concatenation forms a temporary string. The temporary string
doesn’t have any lifetime parameters. It owns its data and has <em>value
semantics</em>. We form a
<code class="sourceCode cpp">string_view</code> using the temporary
string. <code class="sourceCode cpp">basic_string_view</code> declares a
named lifetime parameter, <code class="sourceCode cpp">a</code>, which
models the lifetime of of the view. The view has <em>reference
semantics</em>, and it needs a lifetime for the purpose of live
analysis. The lifetime of this view will originate with a loan on a
string, which owns the data, and is kept live when using the view.
Mutating or dropping the string while there’s a live loan on it makes
the program ill-formed. This is how borrow checking protects against
use-after-free errors.</p>
<p>Initializing <code class="sourceCode cpp">sv</code> invokes the
conversion function on that temporary. The conversion function
<em>borrows</em> self, meaning there’s a loan on the object of the call
(that is, the temporary object). The lifetime argument written out in
the conversion functions’ declaration; rather, it’s assigned during
lifetime elision, which is part of <a href="#lifetime-normalization">normalization</a>. The return type of the
conversion function is a string_view. Since string_view has a lifetime
parameter, <code class="sourceCode cpp">a</code>, lifetime elision
invents a lifetime argument for the return type and constrains the
lifetime of the <code class="sourceCode cpp">self</code> reference to
outlive it. This is all established in the declaration. Callers don’t
look inside function definitions during borrow checking. Both the caller
and callee agree on the lifetime contracts. This creates a chain of
constraints that relate all uses of a reference to its original
loan.</p>
<p>The <code class="sourceCode cpp">str</code> accessor provides the
implementation. It constructs a
<code class="sourceCode cpp">basic_string_view</code> and bypasses the
runtime UTF-8 check by passing a
<code class="sourceCode cpp">no_utf_check</code> argument. As with Rust,
Safe C++ strings guarantee their contents are well-formed UNICODE code
points.</p>
<p>When we print the view the compiler raises this use-after-free error.
The call to <code class="sourceCode cpp">println</code> <em>uses</em>
the lifetime arguments associated with the function argument
<code class="sourceCode cpp">sv</code>. The middle-end solves the <a href="#systems-of-constraints">constraint equation</a>, and puts the
original loan on the string temporary object <em>in scope</em> at all
program points between the string concatenation and the
<code class="sourceCode cpp">println</code> call. The borrow checker
pass looks for invalidating actions on places that overloap in-scope
loans. There’s a drop of the temporary string at the end of the full
expression containing the string concatenation. This isn’t anything
special to Safe C++, this is ordinary RAII cleanup of objects as they
fall out of lexical scope. The drop is a kind of write, and it
invalidates the shared borrow taken on the temporary when its conversion
operator to <code class="sourceCode cpp">string_view</code> was
called.</p>
<p>Unlike previous attempts at lifetime safety<span class="citation" data-cites="P1179R1">[<a href="https://wg21.link/p1179r1" role="doc-biblioref">P1179R1</a>]</span>, borrow checking is absolutely
robust. It does not rely on heuristics that can fail. It allows for any
distance between the use of a borrow and an invalidating action on an
originating loan, with any amount of complex control flow between. MIR
analysis will solve the constraint equation, run the borrow checker, and
issue a diagnostic.</p>
<h3 data-number="2.2.2" id="iterator-invalidation"><span class="header-section-number">2.2.2</span> Iterator invalidation<a href="#iterator-invalidation" class="self-link"></a></h3>
<p>Let’s take a closer look at the iterator invalidation example.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/iterator.cxx"><strong>iterator.cxx</strong></a>
– <a href="https://godbolt.org/z/vneosEGrK">(Compiler Explorer)</a></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>  std2<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec <span class="op">{</span> <span class="dv">11</span>, <span class="dv">15</span>, <span class="dv">20</span> <span class="op">}</span>;</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> x <span class="op">:</span> vec<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Ill-formed. mutate of vec invalidates iterator in ranged-for.</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>x <span class="op">%</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>      mut vec<span class="op">.</span>push_back<span class="op">(</span>x<span class="op">)</span>;</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    std2<span class="op">::</span>println<span class="op">(</span>x<span class="op">)</span>;</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>$ circle iterator.cxx -I ../libsafecxx/include/</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>safety: during safety checking of int main() safe</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  borrow checking: iterator.cxx:10:11</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        mut vec.push_back(x);</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>            ^</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  mutable borrow of vec between its shared borrow and its use</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  loan created at iterator.cxx:7:15</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    for(int x : vec) {</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                ^</span></code></pre></div>
<p>The <em>ranged-for</em> creates an iterator on the vector. The
iterator is initialized for the whole duration of the loop. This is a
shared borrow, because the iterator provides read-only access to the
container. Inside the loop, we mutate the container. The
<code class="sourceCode cpp">mut</code> keyword enters the <a href="#the-mutable-context">mutable context</a> which enables binding
mutable borrows to lvalues in the standard conversion during overload
resolution for the push_back call. Now there’s a shared borrow that’s
live, for the iterator, and a mutable borrow that’s live, for the
push_back. That violates exclusivity and the borrow checker raises an
error.</p>
<p>To users, iterator invalidation looks like a different phenomenon
than the use-after-free defect in the previous section. But to the
compiler, and hopefully to library authors, they can be reasoned about
similarly, as they’re both borrow checker violations.</p>
<blockquote>
<p>The static analysis based on the proposed lifetime annotations cannot
catch all memory safety problems in C++ code. Specifically, it cannot
catch all temporal memory safety bugs (for example, ones caused by
iterator invalidation), and of course lifetime annotations don’t help
with spatial memory safety (for example, indexing C-style arrays out of
bounds). See the comparison with Rust below for a detailed
discussion.</p>
<p>– <cite>[RFC] Lifetime annotations for C++ Clang Frontend</cite><span class="citation" data-cites="clang-lifetime-annotations">[<a href="https://discourse.llvm.org/t/rfc-lifetime-annotations-for-c/61377" role="doc-biblioref">clang-lifetime-annotations</a>]</span></p>
</blockquote>
<p>Clang’s lifetime annotations project doesn’t implement borrow
checking. For that project, iterator invalidation is out of scope,
because it really is a different phenomenon than the lifetime tracking
<em>heuristics</em> employed in detecting other use-after-free
defects.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> slice_iterator<span class="op">/(</span>a<span class="op">)</span>;</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>impl vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">:</span> make_iter <span class="op">{</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> iter_type <span class="op">=</span> slice_iterator<span class="op">&lt;</span>T <span class="kw">const</span><span class="op">&gt;</span>;</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> iter_mut_type <span class="op">=</span> slice_iterator<span class="op">&lt;</span>T<span class="op">&gt;</span>;</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> into_iter_type  <span class="op">=</span> into_iterator<span class="op">&lt;</span>T<span class="op">&gt;</span>;</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>  iter_type iter<span class="op">(</span>self <span class="kw">const</span><span class="op">^)</span> <span class="kw">noexcept</span> safe <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> slice_iterator<span class="op">&lt;</span><span class="kw">const</span> T<span class="op">&gt;(</span>self<span class="op">.</span>slice<span class="op">())</span>;</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>  iter_mut_type iter<span class="op">(</span>self<span class="op">^)</span> <span class="kw">noexcept</span> safe <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> slice_iterator<span class="op">&lt;</span>T<span class="op">&gt;(</span>self<span class="op">.</span>slice<span class="op">())</span>;</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>  into_iter_type iter<span class="op">(</span>self<span class="op">)</span> <span class="kw">noexcept</span> safe <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> p <span class="op">=</span> self<span class="op">^.</span>data<span class="op">()</span>;</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> len <span class="op">=</span> self<span class="op">.</span>size<span class="op">()</span>;</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>    forget<span class="op">(</span>rel self<span class="op">)</span>;</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>    unsafe <span class="op">{</span> <span class="cf">return</span> into_iter_type<span class="op">(</span>p, p <span class="op">+</span> len<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>To opt into ranged-for iteration, containers implement the <code class="sourceCode cpp">std2<span class="op">::</span>make_iter</code>
interface. They can provide const iterators, mutable iterators or
<em>consuming iterators</em> which take ownership of of the operand’s
data and destroy that container in the process.</p>
<p>Because the <em>range-initializer</em> of the loop is an lvalue of
vector that’s outside of the mutable context, the const iterator
overload of <code class="sourceCode cpp">make_iter<span class="op">::</span>iter</code> is
chosen. That returns an <code class="sourceCode cpp">std2<span class="op">::</span>slice_iterator</code>
into the vector’s contents. Here’s the first borrow: lifetime elision
invents a lifetime parameter for the <code class="sourceCode cpp">self <span class="kw">const</span><span class="op">^</span></code>
parameter, which is also used for the named lifetime argument
<code class="sourceCode cpp">a</code> of the
<code class="sourceCode cpp">slice_iterator</code> return type. As with
the use-after-free example, the <code class="sourceCode cpp">make_iter<span class="op">::</span>iter</code>
function declaration establishes an <em>outlives-constraint</em>: the
self operand must outlive the result object.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> slice_iterator<span class="op">/(</span>a<span class="op">)</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  T<span class="op">*</span> unsafe p_;</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  T<span class="op">*</span> end_;</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  T<span class="op">^/</span>a __phantom_data;</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>  slice_iterator<span class="op">([</span>T; dyn<span class="op">]^/</span>a s<span class="op">)</span> <span class="kw">noexcept</span> safe</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span> p_<span class="op">((*</span>s<span class="op">)~</span>as_pointer<span class="op">)</span>, unsafe end_<span class="op">((*</span>s<span class="op">)~</span>as_pointer <span class="op">+</span> <span class="op">(*</span>s<span class="op">)~</span>length<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>  optional<span class="op">&lt;</span>T<span class="op">^/</span>a<span class="op">&gt;</span> next<span class="op">(</span>self<span class="op">^)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>self<span class="op">-&gt;</span>p_ <span class="op">==</span> self<span class="op">-&gt;</span>end_<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">.</span>none; <span class="op">}</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">.</span>some<span class="op">(^*</span>self<span class="op">-&gt;</span>p_<span class="op">++)</span>;</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>The compiler drains the iterator by calling
<code class="sourceCode cpp">next</code> until the optional it returns
is <code class="sourceCode cpp"><span class="op">.</span>none</code>.
Each invocation of <code class="sourceCode cpp">slice_iterator<span class="op">:</span>next</code>
forms a borrow to the current element and advances the current pointer.
Because we chose the const iterator, the template parameter is deduced
as <code class="sourceCode cpp">T<span class="op">=</span><span class="kw">const</span> <span class="dt">int</span></code>.
Lifetime elision invents a lifetime parameter and attaches it to both
the mutable self borrow and the shared borrow inside the optional.
Again, the lifetime on the self parameter <em>outlives</em> the lifetime
on the result object. These lifetime constraints feed the <a href="#systems-of-constraints">constraint equation</a> to enable
inter-procedural live analysis.</p>
<p>It’s the periodic call into <code class="sourceCode cpp">next</code>
that keeps the original borrow on
<code class="sourceCode cpp">vec</code> live. Even though the use of
next is lexically before the push_back (it’s at the top of the loop,
rather than inside the loop), control flow analysis shows that it’s also
<em>downstream</em> of the push_back. MIR analysis follows the backedge
from the end of the body of the loop back to its start. That establishes
the liveness of the shared borrow on vec.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">+&gt;</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> vector <span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> push_back<span class="op">(</span>self<span class="op">^</span>, T t<span class="op">)</span> safe <span class="op">{</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>self<span class="op">.</span>capacity<span class="op">()</span> <span class="op">==</span> self<span class="op">.</span>size<span class="op">())</span> <span class="op">{</span> self<span class="op">.</span>grow<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    __rel_write<span class="op">(</span>self<span class="op">-&gt;</span>p_ <span class="op">+</span> self<span class="op">-&gt;</span>size_, rel t<span class="op">)</span>;</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span>self<span class="op">-&gt;</span>size_;</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>The user enters the mutable context with the
<code class="sourceCode cpp">mut</code> token and calls push_back. This
enables binding a mutable borrow to vec in a standard conversion during
overload resolution to push_back. Since the shared borrow that was taken
to produce slice_iterator is still in scope, the new mutable borrow
violates exclusivity and the program is ill-formed.</p>
<p>Borrow checking is attractive because it’s a unified treatment for
enforcing dependencies. Compiler engineers aren’t asked to develop
heuristics for use-after-free, different ones for iterator invalidation,
and still more clever ones for thread safety. Developers simply employ
the borrow types and the compiler will enforce the attendant
constraints.</p>
<h3 data-number="2.2.3" id="initializer-lists"><span class="header-section-number">2.2.3</span> Initializer lists<a href="#initializer-lists" class="self-link"></a></h3>
<p>Almost every part of the C++ Standard Library will exhibit unsound
behavior even when used in benign-looking ways. Much of it was designed
without consideration of memory safety. This goes even to the most core
types, like <code class="sourceCode cpp">std<span class="op">::</span>initializer_list</code>.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/initlist0.cxx"><strong>initlist0.cxx</strong></a></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string_view&gt;</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>  initializer_list<span class="op">&lt;</span>string_view<span class="op">&gt;</span> initlist1;</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>  initializer_list<span class="op">&lt;</span>string_view<span class="op">&gt;</span> initlist2;</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>  string s <span class="op">=</span> <span class="st">&quot;Hello&quot;</span>;</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>  string t <span class="op">=</span> <span class="st">&quot;World&quot;</span>;</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// initializer lists holds dangling pointers into backing array.</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>  initlist1 <span class="op">=</span> <span class="op">{</span> s, s, s, s <span class="op">}</span>;</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>  initlist2 <span class="op">=</span> <span class="op">{</span> t, t, t, t <span class="op">}</span>;</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Prints like normal.</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span>string_view<span class="op">&gt;</span> vec<span class="op">(</span>initlist1<span class="op">)</span>;</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span>string_view sv <span class="op">:</span> vec<span class="op">)</span></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>    cout<span class="op">&lt;&lt;</span> sv<span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Catastrophe.</span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>  vec <span class="op">=</span> initlist2;</span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span>string_view sv <span class="op">:</span> vec<span class="op">)</span></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>    cout<span class="op">&lt;&lt;</span> sv<span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb34"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>$ clang++ initlist0.cxx -o initlist0 -stdlib=libc++ -O2</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>$ ./initlist0</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>Hello</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>Hello</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>Hello</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>Hello</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>__cxa_guard_release%s failed to broadcast__cxa_guard_abortunexpected_handler une</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>xpectedly returnedterminate_handler unexpectedly returnedterminate_handler unexp</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>ectedly threw an exceptionPure virtual function called!Deleted virtual function</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>called!std::exceptionstd::bad_exceptionstd::bad_allocbad_array_new_lengthSt9exce</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>ptionSt13bad_exceptionSt20bad_array_new_lengthSt9bad_alloc�a���a��b��b��0b��St12</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>domain_errorSt11logic_errorSt16invalid_argumentSt12length_errorSt12out_of_rangeS</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>t11range_errorSt13runtime_errorSt14overflow_errorSt15underflow_errorstd::bad_cas</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>tstd::bad_typeidSt9type_infoSt8bad_castSt10bad_typeidlibc++abi: reinterpret_cast</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>&lt;size_t&gt;(p + 1) % RequiredAlignment == 0/home/sean/projects/llvm-new/libcxxabi/s</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>rc/fallback_malloc.cppvoid *(anonymous namespace)::fallback_malloc(size_t)reinte</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>rpret_cast&lt;size_t&gt;(ptr) % RequiredAlignment == 0N10__cxxabiv116__shim_type_infoE</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>N10__cxxabiv117__class_type_infoEN10__cxxabiv117__pbase_type_infoEN10__cxxabiv11</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>9__pointer_type_infoE</span></code></pre></div>
<p>This example declares two initializer lists of string views,
<code class="sourceCode cpp">initlist1</code> and
<code class="sourceCode cpp">initlist2</code>, declares two strings, and
assigns views of the strings into the two initializer lists. Printing
their contents is undefined behavior. It may go undetected. But
compiling with clang -O2 and targeting libc++ manifests the defect: the
program is printing uncontrollably from some arbitrary place in memory.
This is the kind of memory safety defect that the NSA and corporate
researchers have been warning industry about.</p>
<p>The defect is perplexing because the string objects
<code class="sourceCode cpp">s</code> and
<code class="sourceCode cpp">t</code> <em>are still in scope</em>! This
is a use-after-free bug, but not with an object the user wrote. It’s a
use-after-free of implicit backing stores that C++ generates when
lowering initializer list expressions.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// initializer lists holds dangling pointers into backing array.</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  initlist1 <span class="op">=</span> <span class="op">{</span> s, s, s, s <span class="op">}</span>;</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  initlist2 <span class="op">=</span> <span class="op">{</span> t, t, t, t <span class="op">}</span>;</span></code></pre></div>
<p>Each statement provisions a 4-element
<code class="sourceCode cpp">string_view</code> array as a backing
store. An initializer list object is simply a pointer into the array and
a length. It’s the pointer into the backing store that’s copied into
<code class="sourceCode cpp">initlist1</code> and
<code class="sourceCode cpp">initlist2</code>. At the end of each full
expression, those backing stores go out of scope, leaving dangling
pointers in the initializer lists. When compiled with aggressive local
storage optimizations, the stack space that hosted the backing store for
<code class="sourceCode cpp"><span class="op">{</span> t, t, t, t <span class="op">}</span></code>
gets reused for other objects. A new initialization overwrites the
pointer and length fields of the string views in that reclaimed backing
store. Printing from the initializer lists prints from the smashed
pointers.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/initlist1.cxx"><strong>initlist1.cxx</strong></a>
– <a href="https://godbolt.org/z/xxdTfdh1d">(Compiler Explorer)</a></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std2<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  initializer_list<span class="op">&lt;</span>string_view<span class="op">&gt;</span> initlist<span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  string s <span class="op">=</span> <span class="st">&quot;Hello&quot;</span><span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  string t <span class="op">=</span> <span class="st">&quot;World&quot;</span><span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// initializer lists holds dangling pointers into backing array.</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  initlist <span class="op">=</span> <span class="op">{</span> s<span class="op">,</span> t<span class="op">,</span> s<span class="op">,</span> t <span class="op">};</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Borrow checker error. `use of initlist depends on expired loan`</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span>string_view<span class="op">&gt;</span> vec<span class="op">(</span>rel initlist<span class="op">);</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span>string_view sv <span class="op">:</span> vec<span class="op">)</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span>sv<span class="op">);</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>$ circle initlist1.cxx -I ../libsafecxx/include/</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>safety: during safety checking of int main() safe</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  borrow checking: initlist1.cxx:16:31</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    vector&lt;string_view&gt; vec(rel initlist);</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>                                ^</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>  use of initlist depends on expired loan</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>  drop of temporary object std2::string_view[4] while mutable borrow of</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    temporary object std2::string_view[4][..] is in scope</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>  loan created at initlist1.cxx:13:14</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    initlist = { s, t, s, t };</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>               ^</span></code></pre></div>
<p>Safe C++ includes a new <code class="sourceCode cpp">std2<span class="op">::</span>initializer_list</code>
which sits side-by-side with the legacy type. The compiler provisions a
backing store to hold the data, and the new initializer list also keeps
pointers into that. The backing store expires at the end of the
assignment state. But borrow checking prevents the use-after-free defect
that troubles <code class="sourceCode cpp">std<span class="op">::</span>initializer_list</code>.
An error is filed where the initializer list constructs a vector: <code class="sourceCode cpp">use of initlist depends on expired loan</code>.</p>
<p>The Safe C++ replacement for initializer lists takes the
<em>ownership and borrowing</em> model to heart by doing both. It
borrows the storage its elements are held in, but it also owns the
elements and calls their destructors. We want to support relocation out
of the initializer list. That means the backing store can’t call the
element destructors, because those elements may have been relocated out
by the user. <code class="sourceCode cpp">std2<span class="op">::</span>initializer_list</code>
is more a vector, in that it destroys un-consumed objects when dropped,
but also like a view, in that sees into another object’s storage.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">+&gt;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> initializer_list<span class="op">/(</span>a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Point to byte data on the stack.</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  T<span class="op">*</span> unsafe _cur;</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  T<span class="op">*</span> _end;</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>  T<span class="op">^/</span>a __phantom_data;</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">explicit</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>  initializer_list<span class="op">([</span>T; dyn<span class="op">]^/</span>a data<span class="op">)</span> <span class="kw">noexcept</span> safe <span class="op">:</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    _cur<span class="op">((*</span>data<span class="op">)~</span>as_pointer<span class="op">)</span>,</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>    unsafe _end<span class="op">((*</span>data<span class="op">)~</span>as_pointer <span class="op">+</span> <span class="op">(*</span>data<span class="op">)~</span>length<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">~</span>initializer_list<span class="op">()</span> safe <span class="kw">requires</span><span class="op">(</span>T<span class="op">~</span>is_trivially_destructible<span class="op">)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">unsafe</span><span class="op">::</span><span class="at">drop_only</span><span class="op">(</span><span class="at">T</span><span class="op">)]]</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">~</span>initializer_list<span class="op">()</span> safe <span class="kw">requires</span><span class="op">(!</span>T<span class="op">~</span>is_trivially_destructible<span class="op">)</span> <span class="op">{</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span>destroy_n<span class="op">(</span>_cur, _end <span class="op">-</span> _cur<span class="op">)</span>;</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>  optional<span class="op">&lt;</span>T<span class="op">&gt;</span> next<span class="op">(</span>self<span class="op">^)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>self<span class="op">-&gt;</span>_cur <span class="op">!=</span> self<span class="op">-&gt;</span>_end<span class="op">)</span></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="op">.</span>some<span class="op">(</span>__rel_read<span class="op">(</span>self<span class="op">-&gt;</span>_cur<span class="op">++))</span>;</span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="op">.</span>none;</span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a>  T<span class="op">*</span> data<span class="op">(</span>self<span class="op">^)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> self<span class="op">-&gt;</span>_cur;</span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> T<span class="op">*</span> data<span class="op">(</span><span class="kw">const</span> self<span class="op">^)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> self<span class="op">-&gt;</span>_cur;</span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a>  std<span class="op">::</span><span class="dt">size_t</span> size<span class="op">(</span><span class="kw">const</span> self<span class="op">^)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>std<span class="op">::</span><span class="dt">size_t</span><span class="op">)(</span>self<span class="op">-&gt;</span>_end <span class="op">-</span> self<span class="op">-&gt;</span>_cur<span class="op">)</span>;</span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-41"><a href="#cb37-41" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Unsafe call to advance. Use this after relocating data out of</span></span>
<span id="cb37-42"><a href="#cb37-42" aria-hidden="true" tabindex="-1"></a>  <span class="co">// data().</span></span>
<span id="cb37-43"><a href="#cb37-43" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> advance<span class="op">(</span>self<span class="op">^</span>, std<span class="op">::</span><span class="dt">size_t</span> size<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb37-44"><a href="#cb37-44" aria-hidden="true" tabindex="-1"></a>    self<span class="op">-&gt;</span>_cur <span class="op">+=</span> <span class="kw">static_cast</span><span class="op">&lt;</span>std<span class="op">::</span><span class="dt">ptrdiff_t</span><span class="op">&gt;(</span>size<span class="op">)</span>;</span>
<span id="cb37-45"><a href="#cb37-45" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb37-46"><a href="#cb37-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-47"><a href="#cb37-47" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb37-48"><a href="#cb37-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p><code class="sourceCode cpp">std2<span class="op">::</span>initializer_list</code>
has a named lifetime parameter, <code class="sourceCode cpp">a</code>,
which puts a constraint on the backing store. The private explicit
constructor is called with compiler magic. The argument is a <a href="#arrays-and-slice">slice</a> borrow to the backing store. Note the
lifetime argument on the borrow is the class’s named lifetime parameter.
This means the backing store outlives the initializer list.</p>
<p>This initializer has a relatively rich interface. Of course you can
query for the pointer to the data and its length. But users may also
call <code class="sourceCode cpp">next</code> to pop off an elmeent at a
time. <code class="sourceCode cpp">initializer_list</code> is
essentially an iterator. But for element types that are trivially
relocatable, users can call <code class="sourceCode cpp">data</code> and
<code class="sourceCode cpp">size</code> to relocate them in bulk, and
then <code class="sourceCode cpp">advance</code> by the number of
consumed elements. When the init list goes out of scope, it destroys all
unconsumed elements.</p>
<h3 data-number="2.2.4" id="scope-and-liveness"><span class="header-section-number">2.2.4</span> Scope and liveness<a href="#scope-and-liveness" class="self-link"></a></h3>
<p>Key to one’s understanding of lifetime safety is the distinction
between scope and liveness. Consider lowering your function to
instructions which are indexed by points. The set of points at which an
object is initialized is its <em>scope</em>. In normal C++, this
corresponds to its lexical scope. In Safe C++, due to
relocation/destructive move, there are points in the lexical scope where
the object may not be initialized, making the scope a subset of the
lexical scope.</p>
<p>The compiler lowers AST to MIR control flow graph and runs
<em>initialization analysis</em>, a form of forward dataflow analysis
that computes the scope of all local variables. If a local variable has
been relocated or dropped, and is then named in an expression, the scope
information helps the compiler flag this as an illegal usage.</p>
<p>Liveness is a different property than scope, but they’re often
confused: users speak of lifetime to mean initialization or scope, while
backend engineers speak of lifetime to mean liveness. Liveness is the
set of points where the value (i.e. a specific bit pattern) stored in a
variable is yet to be used.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span><span class="op">)</span>;</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x <span class="op">=</span> <span class="dv">1</span>;  <span class="co">// x is live due to use of 1 below.</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  f<span class="op">(</span>x<span class="op">)</span>;       <span class="co">// not live, because 1 isn&#39;t loaded out again.</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> <span class="dv">2</span>;      <span class="co">// not live, because 2 isn&#39;t loaded out.</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> <span class="dv">3</span>;      <span class="co">// live because 3 is used below.</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>  f<span class="op">(</span>x<span class="op">)</span>;       <span class="co">// still live, because 3 is used below.</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>  f<span class="op">(</span>x<span class="op">)</span>;       <span class="co">// not live, because 3 isn&#39;t used again.</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Live analysis is a reverse dataflow computation. Start at the return
instruction of the control flow graph and work your way up to the entry
point. When you encounter a load instruction, that variable becomes
live. When you encounter a store instruction, that variable is marked
dead.</p>
<p>The liveness property is useful in register alloction: you only care
about representing a variable in register while it’s holding a value
that has yet to be used. But we’re solving lifetime safety, we’re not
doing code generation. Here, we’re only concerned with liveness as a
property of <em>borrows</em>.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span><span class="op">)</span>;</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span><span class="op">^</span> ref;   <span class="co">// An uninitialized borrow.</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">1</span>;</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    ref <span class="op">=</span> <span class="op">^</span>x; <span class="co">// *ref is dereferenced below, so ref is live.</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    f<span class="op">(*</span>ref<span class="op">)</span>;  <span class="co">// now ref is dead.</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> y <span class="op">=</span> <span class="dv">2</span>;</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    ref <span class="op">=</span> <span class="op">^</span>y; <span class="co">// ref is live again</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    f<span class="op">(*</span>ref<span class="op">)</span>;  <span class="co">// ref is still live, due to read below.</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>  f<span class="op">(*</span>ref<span class="op">)</span>;    <span class="co">// ref was live but y was uninitialized.</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Borrows are checked references. It’s a compile-time error to use a
borrow after the data it refers to has gone out of scope. Consider the
set of all live references at each point in the program. Is there an
invalidating action on a place referred to by one of these live
references? If so, that’s a contradiction that makes the program
ill-formed. In this example, the contradiction occurs when
<code class="sourceCode cpp">y</code> goes out of scope, because at that
point, <code class="sourceCode cpp">ref</code> is a live reference to
it. What makes <code class="sourceCode cpp">ref</code> live at that
point?–The last <code class="sourceCode cpp">f<span class="op">(*</span>ref<span class="op">)</span></code>
expression in the program.</p>
<p>It’s not enough to compute liveness of references. To determine the
invalidating actions, it’s important to know which place the live borrow
refers to. <code class="sourceCode cpp">ref</code> is live until the end
of the function, but <code class="sourceCode cpp">x</code> going out of
scope is not an invalidating function, because
<code class="sourceCode cpp">ref</code> doesn’t refer to
<code class="sourceCode cpp">x</code> anymore. We need data structures
that indicate not just when a borrow is live, but to which places it may
refer.</p>
<h3 data-number="2.2.5" id="systems-of-constraints"><span class="header-section-number">2.2.5</span> Systems of constraints<a href="#systems-of-constraints" class="self-link"></a></h3>
<p>NLL borrow checking<span class="citation" data-cites="borrow-checking">[<a href="https://rust-lang.github.io/rfcs/2094-nll.html" role="doc-biblioref">borrow-checking</a>]</span> is Rust’s innovative
method for testing invalidating actions against live borrows in the
presence of control flow. The algorithm involves generating a system of
lifetime constraints which map borrow variables back to <em>loans</em>,
growing points until all the constraints are satisfied, and then testing
invalidating actions against all loans in scope.</p>
<p>A loan is the action that forms a borrow to a place. In the example
above, there are two loans:
<code class="sourceCode cpp"><span class="op">^</span>x</code> and
<code class="sourceCode cpp"><span class="op">^</span>y</code>. Solving
the constraint equation extends the liveness of loans
<code class="sourceCode cpp"><span class="op">^</span>x</code> for and
<code class="sourceCode cpp"><span class="op">^</span>y</code> up until
the point of the last dereferences to them. When
<code class="sourceCode cpp">y</code> goes out of scope, it doesn’t
invalidate the loan
<code class="sourceCode cpp"><span class="op">^</span>x</code>, because
that’s not live. But it does invalidate the loan
<code class="sourceCode cpp"><span class="op">^</span>y</code>, which is
lifetime extended by the final <code class="sourceCode cpp">f<span class="op">(*</span>ref<span class="op">)</span></code>
expression.</p>
<p>Liveness is stored in bit vectors called
<code class="sourceCode cpp">regions</code>. There’s a region for loans
<code class="sourceCode cpp"><span class="op">^</span>x</code> and
<code class="sourceCode cpp"><span class="op">^</span>y</code> and
there’s a region for variables with borrow types, such as
<code class="sourceCode cpp">ref</code>. There are also regions for
user-defined types with lifetime parameters, such as
<code class="sourceCode cpp">string_view</code>.</p>
<p>A lifetime constraint <code class="sourceCode cpp"><span class="ch">&#39;R</span><span class="er">0 : </span><span class="ch">&#39;</span>R1 <span class="op">:</span> P</code>
reads “region 0 outlives region 1 at point P.” The compiler emits
constraints when encountering assignment and function calls involving
types with regions.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span><span class="op">)</span>;</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>P0<span class="op">:</span>   <span class="dt">int</span><span class="op">^</span> ref;          <span class="co">// ref is &#39;R0</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>P1<span class="op">:</span>     <span class="dt">int</span> x <span class="op">=</span> <span class="dv">1</span>;</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>P2<span class="op">:</span>     <span class="op">&lt;</span>loan R1<span class="op">&gt;</span> <span class="op">=</span> <span class="op">^</span>x;  <span class="co">// ^x is loan &#39;R1</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>P3<span class="op">:</span>     ref <span class="op">=</span> <span class="op">&lt;</span>loan R1<span class="op">&gt;</span>; <span class="co">// &#39;R1 : &#39;R0 @ P3</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>P4<span class="op">:</span>     f<span class="op">(*</span>ref<span class="op">)</span>;</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>P5<span class="op">:</span>     <span class="dt">int</span> y <span class="op">=</span> <span class="dv">2</span>;</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>P6<span class="op">:</span>     <span class="op">&lt;</span>loan R2<span class="op">&gt;</span> <span class="op">=</span> <span class="op">^</span>y;  <span class="co">// ^y is loan &#39;R2</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>P7<span class="op">:</span>     ref <span class="op">=</span> <span class="op">&lt;</span>loan R2<span class="op">&gt;</span>; <span class="co">// &#39;R2 : &#39;R0 @ P7</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>P8<span class="op">:</span>     f<span class="op">(*</span>ref<span class="op">)</span>;</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>P9<span class="op">:</span>     drop y</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>P10<span class="op">:</span>    drop x</span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>P11<span class="op">:</span>  f<span class="op">(*</span>ref<span class="op">)</span>;</span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>I’ve relabelled the example to show function points and region names
of variables and loans. If we run live analysis on ’R0, the region for
the variable <code class="sourceCode cpp">ref</code>, we see it’s live
at points ’R0 = { 4, 8, 9, 10, 11 }. We’ll grow the loan regions ’R1 and
’R2 until their constraint equations are satisfied.</p>
<p><code class="sourceCode cpp"><span class="ch">&#39;R</span><span class="er">1 : </span><span class="ch">&#39;</span>R0 <span class="op">@</span> P3</code>
means that starting at P3, the ’R1 contains all points ’R0 does, along
all control flow paths, as long as ’R0 is live. ’R1 = { 3, 4 }. Grow ’R2
the same way: ’R2 = { 7, 8, 9, 10, 11 }.</p>
<p>Now we can hunt for contradictions. Visit each point in the function
and consider, “is there a read, write, move, drop or other invalidating
action on any of the loans in scope?” The only potential invalidating
actions are the drops of <code class="sourceCode cpp">x</code> and
<code class="sourceCode cpp">y</code> where they fall out of scope. At
P9, the loan
<code class="sourceCode cpp"><span class="op">^</span>y</code> is in
scope, because P9 is an element of its region ’R2. This is a conflicting
action, because the loan is also on the variable
<code class="sourceCode cpp">y</code>. That raises a borrow checker
error. There’s also a drop at P10. P10 is in the region for
<code class="sourceCode cpp"><span class="op">^</span>y</code>, but that
is not an invalidating action, because the loan is not on a place that
overlaps with with <code class="sourceCode cpp">x</code>, the operand of
the drop.</p>
<p>The law of exclusivity is enforced at this point. A new mutable loan
is an invalidating action on loans that are live at an overlapping
place. A new shared loan is an invalidating action on mutable loans that
are live at an overlapping place. Additionally, storing to variables is
always an invalidating action when there is any loan, shared or mutable,
on an overlapping place.</p>
<h3 data-number="2.2.6" id="lifetime-error-reporting"><span class="header-section-number">2.2.6</span> Lifetime error reporting<a href="#lifetime-error-reporting" class="self-link"></a></h3>
<p>The borrow checker is concerned with invalidating actions on in-scope
loans. There are three instructions at play:</p>
<ul>
<li><strong>(B)</strong> The creation of the loan. This is the
lvalue-to-borrow operation, equivalent to an addressof (&amp;).</li>
<li><strong>(A)</strong> The action that invalidates the loan. That
includes taking a mutable borrow on a place with a shared loan, or
taking any borrow or writing to a place with a mutable borrow. These
actions could lead to use-after-free bugs.</li>
<li><strong>(U)</strong> A use that extends the liveness of the borrow
past the point of the invalidating action.</li>
</ul>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/view.cxx"><strong>view.cxx</strong></a>
– <a href="https://godbolt.org/z/f663aeeoh">(Compiler Explorer)</a></p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  std2<span class="op">::</span>string s <span class="op">=</span> <span class="st">&quot;Hello safety&quot;</span>;</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// (B) - borrow occurs here.</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>  std2<span class="op">::</span>string_view view <span class="op">=</span> s;</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// (A) - invalidating action</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>  s <span class="op">=</span> <span class="st">&quot;A different string&quot;</span>;</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// (U) - use that extends borrow</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span>view<span class="op">)</span>;</span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>$ circle view.cxx</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>safety: during safety checking of int main() safe</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  borrow checking: view.cxx:14:11</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    println(view);</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>            ^</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  use of view depends on expired loan</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  drop of s between its shared borrow and its use</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  invalidating operation at view.cxx:11:5</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    s = &quot;A different string&quot;;</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>      ^</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  loan created at view.cxx:8:28</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    std2::string_view view = s;</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>                             ^</span></code></pre></div>
<p>Circle tries to identify all three of these points when forming
borrow checker errors. Usually they’re printed in bottom-to-top order.
That is, the first source location printed is the location of the use of
the invalidated loan. Next, the invalidating action is categorized and
located. Lastly, the creation of the loan is indicated.</p>
<p>The invariants that are tested are established with a network of
lifetime constraints. It might not be the case that the invalidating
action is obviously related to either the place of the loan or the use
that extends the loan. More completely describing the chain of
constraints could users diagnose borrow checker errors. But there’s a
fine line between presenting an error like the one above, which is
already pretty wordy, and inundating programmers with too much
information.</p>
<h3 data-number="2.2.7" id="lifetime-constraints-on-called-functinos"><span class="header-section-number">2.2.7</span> Lifetime constraints on
called functinos<a href="#lifetime-constraints-on-called-functinos" class="self-link"></a></h3>
<p>Borrow checking is really easy to understand when applied to a single
function. The function is lowered to a control flow graph, the compiler
assigns regions to loans and borrow variables, emits lifetime
constraints where there are assignments, iteratively grows regions until
the constraints are solved, and walks the instructions, checking for
invalidating actions on loans in scope. The compiler automatically
assigns regions to all loans and borrow variables. Within the definition
of the function, there’s nothing it can’t analyze. The complexity arises
when passing and receiving borrows through function calls.</p>
<p>Whole program analysis is not practical. In order to extend static
lifetime safety guarantees outside of single functions, we have to
introduce <em>lifetime contracts</em> on function boundaries that are
satisfied by both caller and callee. These contracts are noted by
<em>lifetime parameters</em>.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> get_x<span class="op">/(</span>a, b<span class="op">)(</span><span class="kw">const</span> <span class="dt">int</span><span class="op">^/</span>a x, <span class="kw">const</span> <span class="dt">int</span><span class="op">^/</span>b y<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">const</span> <span class="dt">int</span><span class="op">^/</span>a <span class="op">{</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x;</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> get_y<span class="op">/(</span>a, b<span class="op">)(</span><span class="kw">const</span> <span class="dt">int</span><span class="op">^/</span>a x, <span class="kw">const</span> <span class="dt">int</span><span class="op">^/</span>b y<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">const</span> <span class="dt">int</span><span class="op">^/</span>b <span class="op">{</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> y;</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> <span class="dt">int</span><span class="op">^</span> ref1;</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> <span class="dt">int</span><span class="op">^</span> ref2;</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x <span class="op">=</span> <span class="dv">1</span>;</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> y <span class="op">=</span> <span class="dv">2</span>;</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>    ref1 <span class="op">=</span> get_x<span class="op">(</span>x, y<span class="op">)</span>;</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>    ref2 <span class="op">=</span> get_y<span class="op">(</span>x, y<span class="op">)</span>;</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> val1 <span class="op">=</span> <span class="op">*</span>ref1;  <span class="co">// OK.</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> val2 <span class="op">=</span> <span class="op">*</span>ref2;  <span class="co">// Borrow checker error.</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>$ circle get.cxx</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>safety: get.cxx:20:14</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  int val2 = *ref2;</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>             ^</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>use of *ref2 depends on expired loan</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>drop of y between its shared borrow and its use</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>y declared at get.cxx:15:9</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    int y = 2;</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        ^</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>loan created at get.cxx:17:21</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    ref2 = get_y(x, y);</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>                    ^</span></code></pre></div>
<p>Inside function declarations and function types, borrow types must be
qualified with lifetime arguments. The arguments name lifetime
parameters associated with the function.</p>
<p><code class="sourceCode cpp">get_x</code> takes two shared borrow
parameters and returns a shared borrow. The return type is marked with
the lifetime parameter
<code class="sourceCode cpp"><span class="op">/</span>a</code>, which
corresponds with the lifetime argument on the returned value
<code class="sourceCode cpp">x</code>.
<code class="sourceCode cpp">get_y</code> is declared to return a shared
borrow with a lifetime associated with the parameter
<code class="sourceCode cpp">y</code>. Since we’re not specifying an
<em>outlives-constraint</em> between the lifetime parameters, the
function bodies can’t assume anything about how these lifetimes relate
to each other. It would be ill-formed for
<code class="sourceCode cpp">get_x</code> to return
<code class="sourceCode cpp">y</code> or
<code class="sourceCode cpp">get_y</code> to return
<code class="sourceCode cpp">x</code>.</p>
<p>The caller, <code class="sourceCode cpp">main</code> performs borrow
checking on its side of the function calls and assumes
<code class="sourceCode cpp">get_x</code> and
<code class="sourceCode cpp">get_y</code> perform borrow checking on
their side of the function calls. The function lifetime
parameterizations define a contract so that each side can be sure that
its caller or callee is upholding program soundness.</p>
<p>Compiling this code raises a borrow checker error when dereferencing
<code class="sourceCode cpp"><span class="op">*</span>ref2</code>, since
it’s a use-after-free. Static analysis on
<code class="sourceCode cpp">main</code> knows this even without looking
into the definition of <code class="sourceCode cpp">get_y</code>. The
lifetime parameterization generates constraints at the point of the
function call, so that the region on the loan on
<code class="sourceCode cpp">y</code> outlives the region on the result
object <code class="sourceCode cpp">ref2</code>.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>P0<span class="op">:</span>   <span class="kw">const</span> <span class="dt">int</span><span class="op">^</span> ref1;        <span class="co">// ref1 is &#39;R0</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>P1<span class="op">:</span>   <span class="kw">const</span> <span class="dt">int</span><span class="op">^</span> ref2;        <span class="co">// ref2 is &#39;R1</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>P2<span class="op">:</span>   <span class="dt">int</span> x <span class="op">=</span> <span class="dv">1</span>;</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y <span class="op">=</span> <span class="dv">2</span>;</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>P3<span class="op">:</span>     <span class="op">&lt;</span>loan R2<span class="op">&gt;</span> <span class="op">=</span> <span class="op">^</span><span class="kw">const</span> x; <span class="co">// ^const x is &#39;R2</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>P4<span class="op">:</span>     <span class="op">&lt;</span>loan R3<span class="op">&gt;</span> <span class="op">=</span> <span class="op">^</span><span class="kw">const</span> y; <span class="co">// ^const y is &#39;R3</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>P5<span class="op">:</span>     ref1 <span class="op">=</span> get_x<span class="op">(&lt;</span>loan R2<span class="op">&gt;</span>, <span class="op">&lt;</span>loan R3<span class="op">&gt;)</span>;</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// /a is &#39;R4.</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// /b is &#39;R5.</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// &#39;R2 : &#39;R4 @ P5</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// &#39;R3 : &#39;R5 @ P5</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// &#39;R4 : &#39;R0 @ P5</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>P6<span class="op">:</span>     <span class="op">&lt;</span>loan R6<span class="op">&gt;</span> <span class="op">=</span> <span class="op">^</span><span class="kw">const</span> x; <span class="co">// ^const x is &#39;R6</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>P7<span class="op">:</span>     <span class="op">&lt;</span>loan R7<span class="op">&gt;</span> <span class="op">=</span> <span class="op">^</span><span class="kw">const</span> y; <span class="co">// ^const y is &#39;R7</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>P8<span class="op">:</span>     ref2 <span class="op">=</span> get_y<span class="op">(&lt;</span>loan R6<span class="op">&gt;</span>, <span class="op">&lt;</span>loan R7<span class="op">&gt;)</span>;</span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// /a is &#39;R8&#39;.</span></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// /b is &#39;R9&#39;.</span></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// &#39;R6 : &#39;R8 @ P8</span></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// &#39;R7 : &#39;R9 @ P8</span></span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// &#39;R9 : &#39;R1 @ P8</span></span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>P9<span class="op">:</span>     drop y</span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a>P10<span class="op">:</span>  <span class="dt">int</span> val1 <span class="op">=</span> <span class="op">*</span>ref1;  <span class="co">// OK.</span></span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a>P11<span class="op">:</span>  <span class="dt">int</span> val2 <span class="op">=</span> <span class="op">*</span>ref2;  <span class="co">// Borrow checker error.</span></span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true" tabindex="-1"></a>P12<span class="op">:</span>  drop x</span>
<span id="cb43-31"><a href="#cb43-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>For every function calls, the lifetime parameters of that function
are assigned regions. The regions of the function arguments outlive
their corresponding lifetime parameters, and the lifetime parameters
outlive their correspond result object parameters. This creates a chain
of custody from the arguments, through the function, and out the result.
The caller doesn’t have to know the definition of the function, because
it upholds the constraints at the point of the call, and the callee
upholds the constraints in the definition of the function.</p>
<p>Let’s solve for the regions of the four loans:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>&#39;R2 = { 4, 5, 6, 7, 8, 9, 10 }</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>&#39;R3 = { 5 }</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>&#39;R6 = { 7, 8, }</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>&#39;R7 = { 8, 9, 10, 11 }</span></code></pre></div>
<p>The drops of <code class="sourceCode cpp">x</code> and
<code class="sourceCode cpp">y</code>, when they go out of scope, are
the potentially invalidating actions.
<code class="sourceCode cpp">y</code> goes out of scope at P9, and the
loans with regions <code class="sourceCode cpp">R2</code> and
<code class="sourceCode cpp">R7</code> are live at P9 (because they have
9 in their sets). The ’R2 loan borrows variable
<code class="sourceCode cpp">x</code>, which is non-overlapping with the
drop operand <code class="sourceCode cpp">y</code>, so it’s not an
invalidating action. The ’R7 loan borrows variable
<code class="sourceCode cpp">y</code>, which is overlapping with the
drop operand <code class="sourceCode cpp">y</code>, so we get a borrow
checker error. The drop of <code class="sourceCode cpp">x</code> is
benign, since no loan is live at P12.</p>
<h3 data-number="2.2.8" id="lifetime-parameters"><span class="header-section-number">2.2.8</span> Lifetime parameters<a href="#lifetime-parameters" class="self-link"></a></h3>
<p>On function types and function declarators, the
<em>lifetime-parameters-list</em> goes right after the
<em>declarator-id</em>.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">// A function type declarator.</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> F1 <span class="op">=</span> <span class="dt">void</span><span class="op">/(</span>a, b<span class="op">)(</span><span class="dt">int</span><span class="op">^/</span>a, <span class="dt">int</span><span class="op">^/</span>b<span class="op">)</span> safe;</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="co">// A function declaration with the same type</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1<span class="op">/(</span>a, b<span class="op">)(</span><span class="dt">int</span><span class="op">^/</span>a, <span class="dt">int</span><span class="op">^/</span>b<span class="op">)</span> safe;</span></code></pre></div>
<p>Borrows are first-class <em>lifetime binders</em>. You can also
declare class and class templates that bind lifetimes by putting
<em>lifetime-parameters-lists</em> after their
<em>declarator-ids</em>.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> char_type<span class="op">&gt;</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> basic_string_view<span class="op">/(</span>a<span class="op">)</span>;</span></code></pre></div>
<p>All types with lifetime binders named in function declarations and
data members must be qualified with lifetime arguments. This helps
define the soundness contract between callers and callees.</p>
<p>Often, it’s necessary to specify requirements between lifetime
parameters. These take the form of <em>outlives-constraints</em>.
They’re specified in a <em>where-clause</em> inside the
<em>lifetime-parameter-list</em>.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> F2 <span class="op">=</span> <span class="dt">void</span><span class="op">/(</span>a, b where a <span class="op">:</span> b<span class="op">)(</span><span class="dt">int</span><span class="op">^/</span>a x, <span class="dt">int</span><span class="op">^/</span>b y<span class="op">)</span> safe;</span></code></pre></div>
<p>Rust chose a different syntax, mixing lifetime parameters and type
parameters into the same parameter list. Coming from C++, where
templates supply our generics, I find this misleading. Lifetime
parameters are really nothing like template parameters. A function with
lifetime parameters isn’t really a generic function. Lifetime parameters
are never substituted with any kind of concrete lifetime argument.
Instead, the relationship between lifetime parameters, as deduced from
<em>outlives-constraints</em>, implied bounds and variances of function
parameters, establishes constraints that are used by the borrow checker
at the point of call.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">// A Rust declaration.</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> f<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> <span class="ot">&#39;b</span><span class="op">,</span> T<span class="op">&gt;</span>(x<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="kw">mut</span> T<span class="op">,</span> y<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;b</span> T) <span class="kw">where</span> <span class="ot">&#39;a</span> <span class="op">:</span> <span class="ot">&#39;b</span> <span class="op">{</span> <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co">// A C++ declaration.</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">/(</span>a, b where a <span class="op">:</span> b<span class="op">)(</span>T<span class="op">^/</span>a x, <span class="kw">const</span> T<span class="op">^/</span>b y<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span></code></pre></div>
<p>Rust uses single-quotes to introduce lifetime parameters and lifetime
arguments. That’s not a workable choice for us, because C supports
multi-character literals. This cursed feature, in which literals like
<code class="sourceCode cpp"><span class="ch">&#39;a</span><span class="er">bcd</span><span class="ch">&#39;</span></code>
evaluate to constants of type
<code class="sourceCode cpp"><span class="dt">int</span></code>, makes
lexing Rust-style lifetime arguments very messy.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">/(</span>a, b where a <span class="op">:</span> b<span class="op">)(</span>T<span class="op">^/</span>a x, <span class="kw">const</span> T<span class="op">^/</span>b y<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x <span class="op">=</span> <span class="dv">1</span>;</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> y <span class="op">=</span> <span class="dv">2</span>;</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>  f<span class="op">(^</span>x, y<span class="op">)</span>;</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>P0<span class="op">:</span>   <span class="dt">int</span> x <span class="op">=</span> <span class="dv">1</span>;</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>P1<span class="op">:</span>   <span class="dt">int</span> y <span class="op">=</span> <span class="dv">2</span>;</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>P2<span class="op">:</span>   <span class="op">&lt;</span>loan R0<span class="op">&gt;</span> <span class="op">=</span> <span class="op">^</span>x;</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>P3<span class="op">:</span>   <span class="op">&lt;</span>loan R1<span class="op">&gt;</span> <span class="op">=</span> <span class="op">^</span><span class="kw">const</span> y;</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>P4<span class="op">:</span>   f<span class="op">(&lt;</span>loan R0<span class="op">&gt;</span>, <span class="op">&lt;</span>loan R1<span class="op">&gt;)</span>;</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>      <span class="co">// /a is &#39;R2</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>      <span class="co">// /b is &#39;R3</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>      <span class="co">// &#39;R2 : &#39;R3 @ P4 - `where a : b`</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>      <span class="co">// &#39;R0 : &#39;R2 @ P4</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>      <span class="co">// &#39;R1 : &#39;R3 @ P4</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>The <em>where-clause</em> establishes the relationship that
<code class="sourceCode cpp"><span class="op">/</span>a</code> outlives
<code class="sourceCode cpp"><span class="op">/</span>b</code>. Does
this mean that the variable pointed at by
<code class="sourceCode cpp">x</code> goes out of scope later than the
variable pointed at by <code class="sourceCode cpp">y</code>? No, that
would be too straight-forward. This declaration emits a
<em>lifetime-constraint</em> at the point of the function call. The
regions of the arguments already constrain the regions of the lifetime
parameters. The <em>where-clause</em> constrains the lifetime parameters
to one another. <code class="sourceCode cpp">f</code>’s outlives
constraint is responsible for the constraint <code class="sourceCode cpp"><span class="ch">&#39;R</span><span class="er">2 : </span><span class="ch">&#39;</span>R3 <span class="op">@</span> P4</code>.</p>
<p>Lifetime parameters and <em>where-clauses</em> are a facility for
instructing the borrow checker. The obvious mental model is that the
lifetimes of references are connected to the scope of the objects they
point to. But this is not accurate. Think about lifetimes as defining
rules that can’t be violated, with the borrow checker looking for
contradictions of these rules.</p>
<h3 data-number="2.2.9" id="free-regions"><span class="header-section-number">2.2.9</span> Free regions<a href="#free-regions" class="self-link"></a></h3>
<h3 data-number="2.2.10" id="destructors-and-phantom-data"><span class="header-section-number">2.2.10</span> Destructors and phantom
data<a href="#destructors-and-phantom-data" class="self-link"></a></h3>
<p>Safe C++ includes an operator to call the destructor on local
objects.</p>
<ul>
<li><code class="sourceCode cpp">drp x</code> - call the destructor on
an object and set as uninitialized.</li>
</ul>
<p>Local objects start off uninitialized. They’re initialized when first
assigned to. Then they’re uninitialized again when relocated from. If
you want to <em>destruct</em> an object prior to it going out of scope,
use <em>drp-expression</em>. Unlike Rust’s
<code class="sourceCode cpp">drop</code> API,<span class="citation" data-cites="drop">[<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html" role="doc-biblioref">drop</a>]</span> this works even on objects that
are pinned or are only potentially initialized (was uninitialized on
some control flow paths) or partially initialized (has some
uninitialized subobjects).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">mut</span> v <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span><span class="op">&lt;&amp;</span><span class="dt">i32</span><span class="op">&gt;</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">101</span><span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    v<span class="op">.</span>push(<span class="op">&amp;</span>x)<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Error: `x` does not live long enough</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  drop(v)<span class="op">;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Rust’s <code class="sourceCode cpp">drop</code> API also performs a
non-drop-use of all lifetimes on the operand. A vector with dangling
lifetimes would pass the normal drop check, but when passed to an
explicit <code class="sourceCode cpp">drop</code> call leaves the
program ill-formed.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>  std2<span class="op">::</span>vector<span class="op">&lt;</span><span class="kw">const</span> <span class="dt">int</span><span class="op">^&gt;</span> vec <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">101</span>;</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    mut vec<span class="op">.</span>push_back<span class="op">(</span>x<span class="op">)</span>;</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Okay. vec has dangling borrows, but passes the drop check.</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>  drp vec;</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <em>drp-expression</em> in Safe C++ only performs a drop use of
the operand’s lifetimes. The logic for establishing lifetime used on
object destruction is part of the <em>drop check</em>.</p>
<p>A user-defined destructor uses the lifetimes associated with all
class data members. However, container types that store data on heap
memory, such as box and vector, don’t store their data as data members,
but instead keep pointers into keep memory. In order to expose data for
the drop check, container types must have phantom data<span class="citation" data-cites="phantom-data">[<a href="https://doc.rust-lang.org/nomicon/phantom-data.html" role="doc-biblioref">phantom-data</a>]</span> to declare a sort of
phantom data.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">+&gt;</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec <span class="op">{</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">~</span>Vec<span class="op">()</span> safe;</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Pointer to the data. Since T* has a trivial destructor, template</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// lifetime parameters of T are not used by Vec&#39;s dtor.</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>  T<span class="op">*</span> _data;</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// For the purpose of drop check, declare a member of type T.</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// This is a phantom data member that does not effect data</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// layout or initialization.</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>  T __phantom_data;</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>Declaring a <code class="sourceCode cpp">__phantom_data</code> member
informs the compiler that the class may destroy objects of type
<code class="sourceCode cpp">T</code> inside the user-defined
destructor. The drop check expects user-defined destructors to be
maximally permissive with its data members, and that it can use any of
the class’s lifetime parameters. In order to permit <em>dangling
references</em> in containers, destructors should opt into the <code class="sourceCode cpp"><span class="op">[[</span><span class="at">unsafe</span><span class="op">::</span><span class="at">drop_only</span><span class="op">(</span><span class="at">T</span><span class="op">)]]</span></code>
attribute. This is available in Rust as the <code class="sourceCode cpp"><span class="pp">#</span><span class="er">[may_dangle]</span></code>
attribute.<span class="citation" data-cites="may-dangle">[<a href="https://rust-lang.github.io/rfcs/1327-dropck-param-eyepatch.html" role="doc-biblioref">may-dangle</a>]</span></p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">+</span>, <span class="dt">bool</span> DropOnly<span class="op">&gt;</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec <span class="op">{</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>  Vec<span class="op">()</span> safe <span class="op">{</span> <span class="op">}</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">unsafe</span><span class="op">::</span><span class="at">drop_only</span><span class="op">(</span><span class="at">T</span><span class="op">)]]</span> <span class="op">~</span>Vec<span class="op">()</span> safe <span class="kw">requires</span><span class="op">(</span>DropOnly<span class="op">)</span>;</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>                           <span class="op">~</span>Vec<span class="op">()</span> safe <span class="kw">requires</span><span class="op">(!</span>DropOnly<span class="op">)</span>;</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> push<span class="op">(</span>self<span class="op">^</span>, T rhs<span class="op">)</span> safe;</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// T is a phantom data member of Vec. The non-trivial dtor will</span></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// use the lifetimes of T, raising a borrow checker error if</span></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// T is not drop_only.</span></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>  T __phantom_data;</span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T, <span class="dt">bool</span> DropOnly<span class="op">&gt;</span></span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> test<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a>  Vec<span class="op">&lt;</span><span class="kw">const</span> T<span class="op">^</span>, DropOnly<span class="op">&gt;</span> vec <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb52-22"><a href="#cb52-22" aria-hidden="true" tabindex="-1"></a>    T x <span class="op">=</span> <span class="dv">101</span>;</span>
<span id="cb52-23"><a href="#cb52-23" aria-hidden="true" tabindex="-1"></a>    mut vec<span class="op">.</span>push<span class="op">(^</span>x<span class="op">)</span>;</span>
<span id="cb52-24"><a href="#cb52-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb52-25"><a href="#cb52-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-26"><a href="#cb52-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Use of vec is ill-formed due to drop of x above.</span></span>
<span id="cb52-27"><a href="#cb52-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">// int y = 102;</span></span>
<span id="cb52-28"><a href="#cb52-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">// mut vec.push(^y);</span></span>
<span id="cb52-29"><a href="#cb52-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-30"><a href="#cb52-30" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Should be ill-formed due to drop check.</span></span>
<span id="cb52-31"><a href="#cb52-31" aria-hidden="true" tabindex="-1"></a>  drp vec;</span>
<span id="cb52-32"><a href="#cb52-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb52-33"><a href="#cb52-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-34"><a href="#cb52-34" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb52-35"><a href="#cb52-35" aria-hidden="true" tabindex="-1"></a>  test<span class="op">&lt;</span><span class="dt">int</span>, <span class="kw">true</span><span class="op">&gt;()</span>;</span>
<span id="cb52-36"><a href="#cb52-36" aria-hidden="true" tabindex="-1"></a>  test<span class="op">&lt;</span><span class="dt">int</span>, <span class="kw">false</span><span class="op">&gt;()</span>;</span>
<span id="cb52-37"><a href="#cb52-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb53"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>$ circle drop.cxx</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>safety: during safety checking of void test&lt;int, false&gt;() safe</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>  borrow checking: drop.cxx:31:3</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    drp vec;</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    ^</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  use of vec depends on expired loan</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>  drop of x between its mutable borrow and its use</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>  x declared at drop.cxx:22:7</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>      T x = 101;</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>        ^</span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>  loan created at drop.cxx:23:18</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>      mut vec.push(^x);</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>                   ^</span></code></pre></div>
<p>This example shows a basic Vec implementation. A
<code class="sourceCode cpp">T __phantom_data</code> member indicates
that <code class="sourceCode cpp">T</code> will be destroyed as part of
the user-defined destructor. The user-defined destructor is
conditionally declared with the <code class="sourceCode cpp"><span class="op">[[</span><span class="at">unsafe</span><span class="op">::</span><span class="at">drop_only</span><span class="op">(</span><span class="at">T</span><span class="op">)]]</span></code>
attribute, which means that the destructor body will only use T’s
lifetime parameters as part of a drop, and not any other use.</p>
<p>The point of this mechanism is to make drop order less important by
permitting the drop of containers that hold dangling references. Declare
a Vec specialized on a shared borrow to int. Push a shared borrow to a
local integer declaration, then make the local integer go out of scope.
The Vec now holds a dangling borrow. This should compile, as long as we
don’t use the template lifetime parameter associated with the borrow.
That would produce a use-after-free borrow checker error.</p>
<p>When <code class="sourceCode cpp">DropOnly</code> is true, the
destructor overload with the <code class="sourceCode cpp"><span class="op">[[</span><span class="at">unsafe</span><span class="op">::</span><span class="at">drop_only</span><span class="op">]]</span></code>
attribute is instantiated. Calling the destructor from
<code class="sourceCode cpp">test</code> doesn’t necessarily use the
template lifetime parameters for the <code class="sourceCode cpp"><span class="kw">const</span> <span class="dt">int</span><span class="op">^</span></code>
template argument. Instead, the drop check considers the destructor for
the <code class="sourceCode cpp"><span class="kw">const</span> <span class="dt">int</span><span class="op">^</span></code>
type. In that case it’s trivial destruction and the lifetime parameter
is not used. This means the <em>drp-expression</em> can destroy the Vec
without a borrow checker violation. The programmer is making an unsafe
promise not to do anything with T’s template lifetime parameters other
than use it to drop T.</p>
<p>When <code class="sourceCode cpp">DropOnly</code> is false, the
destructor overload without the attribute is instantiated. In this case,
the user-defined destructor is assumed to use all of the class’s
lifetime parameters outside of the drop check. If the Vec held a borrow
to out-of-scope data, as it does in this example, loading that data
through the borrow would be a use-after-free defect. To prevent this
unsound behavior, the compiler uses all the class’s lifetime parameters
when its user-defined destructor is called. This raises the borrow
checker error, indicating that the <em>drp-expression</em> depends on an
expired loan on <code class="sourceCode cpp">x</code>.</p>
<p>The <code class="sourceCode cpp">drop_only</code> attribute is
currently unsafe because it’s incumbent on the programmer implementing a
destructor that doesn’t use associated lifetime parameters outside of
invoking their destructors. We plan to make this attribute safe. The
compiler should be able to monitor the user-defined destructor for use
of lifetimes associated with T outside of drops and raise borrow checker
errors. However, that may require extending
<code class="sourceCode cpp">drop_only</code> to all functions, not just
destructors. <code class="sourceCode cpp">std<span class="op">::</span>destruct_at</code>
involves a non-drop use of the parameter type. But a
<code class="sourceCode cpp">drop_only</code>-attributed <code class="sourceCode cpp">std2<span class="op">::</span>destruct_at</code>
would only permit and qualify as a drop use.</p>
<h3 data-number="2.2.11" id="lifetime-canonicalization"><span class="header-section-number">2.2.11</span> Lifetime canonicalization<a href="#lifetime-canonicalization" class="self-link"></a></h3>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Two distinct lifetimes with no constraint.</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> F1 <span class="op">=</span> <span class="dt">void</span><span class="op">/(</span>a, b<span class="op">)(</span><span class="dt">int</span><span class="op">^/</span>a, <span class="dt">int</span><span class="op">^/</span>b<span class="op">)</span> safe;</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="co">// These are the same.</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> F2 <span class="op">=</span> <span class="dt">void</span><span class="op">/(</span>a, b where a <span class="op">:</span> b<span class="op">)(</span><span class="dt">int</span><span class="op">^/</span>a, <span class="dt">int</span><span class="op">^/</span>b<span class="op">)</span> safe;</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> F3 <span class="op">=</span> <span class="dt">void</span><span class="op">/(</span>a, b where b <span class="op">:</span> a<span class="op">)(</span><span class="dt">int</span><span class="op">^/</span>b, <span class="dt">int</span><span class="op">^/</span>a<span class="op">)</span> safe;</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>F2 <span class="op">==</span> F3<span class="op">)</span>;</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a><span class="co">// They differ from F1, due to the outlives-constraint.</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>F1 <span class="op">!=</span> F2<span class="op">)</span>;</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a><span class="co">// These are the same.</span></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> F4 <span class="op">=</span> <span class="dt">void</span><span class="op">/(</span>a, b where a <span class="op">:</span> b, b <span class="op">:</span> a<span class="op">)(</span><span class="dt">int</span><span class="op">^/</span>a, <span class="dt">int</span><span class="op">^/</span>b<span class="op">)</span> safe;</span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> F5 <span class="op">=</span> <span class="dt">void</span><span class="op">/(</span>a<span class="op">)</span>                      <span class="op">(</span><span class="dt">int</span><span class="op">^/</span>a, <span class="dt">int</span><span class="op">^/</span>a<span class="op">)</span> safe;</span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>F4 <span class="op">==</span> F5<span class="op">)</span>;</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a><span class="co">// They differ from F2, due to the constraint going both directions.</span></span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>F2 <span class="op">!=</span> F4<span class="op">)</span>;</span></code></pre></div>
<p>Lifetime parameterizations are part of the function’s type. But
different textual parameterizations may still result in the same type!
<code class="sourceCode cpp">F1</code> and
<code class="sourceCode cpp">F2</code> have different parameterizations
and are different types. But <code class="sourceCode cpp">F2</code> and
<code class="sourceCode cpp">F3</code> have different parameterizations
yet are the same type. Likewise, <code class="sourceCode cpp">F4</code>
and <code class="sourceCode cpp">F5</code> are the same type, even
though <code class="sourceCode cpp">F4</code> has two lifetime
parameters and two outlives constraints.</p>
<p>The compiler maps all non-dependent types to canonical types. When
comparing types for equality, it compares the pointers to their
canonical types. This is necessary to support typedefs and alias
templates that appear in functions–we need to strip away those
inessential details and get to the canonical types within. The lifetime
parameterizations the user writes also map to canonical
pameterizations.</p>
<p>Think about lifetime parameterizations as a directed graph. Lifetime
parameters are the nodes and outlives constraints define the edges. The
compiler finds the strongly connected components<span class="citation" data-cites="scc">[<a href="https://en.wikipedia.org/wiki/Strongly_connected_component" role="doc-biblioref">scc</a>]</span> of this graph. That is, it
identifies all cycles and reduces them into SCC nodes. In
<code class="sourceCode cpp">F4</code>, the
<code class="sourceCode cpp"><span class="op">/</span>a</code> and
<code class="sourceCode cpp"><span class="op">/</span>b</code> lifetime
parameters constrain one another, and there are collapsed into a
strongly connected component. The canonical function type is encoded
using SCCs as lifetime parameters. Both
<code class="sourceCode cpp">F4</code> and
<code class="sourceCode cpp">F5</code> map to the same canonical type,
and therefore compare the same.</p>
<p>During the type relation pass that generates lifetime constraints for
function calls in the MIR, arguments and result object regions are
constrained to regions of the canonical type’s SCCs, rather than the
lifetime parameters of the declared type. This reduces the number of
regions the borrow checker solves for. But the big reason for this
process is to permit writing compatible functions even in the face
lifetime normalization.</p>
<h3 data-number="2.2.12" id="lifetimes-and-templates"><span class="header-section-number">2.2.12</span> Lifetimes and templates<a href="#lifetimes-and-templates" class="self-link"></a></h3>
<p>Templates are specially adapted to handle types with lifetime
binders. It’s important to understand how template lifetime parameters
are invented in order to understand how borrow checking fits with C++’s
late-checked generics.</p>
<p>Class templates feature a variation on the type template parameter:
<code class="sourceCode cpp"><span class="kw">typename</span> T<span class="op">+</span></code>
is a lifetime binder parameter. The class template invents an implicit
<em>template lifetime parameter</em> for each lifetime binder of the
argument’s type.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T0<span class="op">+</span>, <span class="kw">typename</span> T1<span class="op">+&gt;</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Pair <span class="op">{</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>  T0 first;</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>  T1 second;</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> string_view<span class="op">/(</span>a<span class="op">)</span>;</span></code></pre></div>
<p>The <code class="sourceCode cpp">Pair</code> class template doesn’t
have any named lifetime parameters.
<code class="sourceCode cpp">string_view</code> has one named lifetime
parameter, which constrains the pointed-at string to outlive the view.
The specialization <code class="sourceCode cpp">Pair<span class="op">&lt;</span>string_view, string_view<span class="op">&gt;</span></code>
invents a template lifetime parameter for each view’s named lifetime
parameters. Call them <code class="sourceCode cpp">T0<span class="fl">.0</span><span class="er">.0</span></code>
and <code class="sourceCode cpp">T1<span class="fl">.0</span><span class="er">.0</span></code>.
<code class="sourceCode cpp">T0<span class="fl">.0</span></code> is for
the 0th parameter pack element of the template parameter pack. <code class="sourceCode cpp">T0<span class="fl">.0</span><span class="er">.0</span></code>
is for the 0th lifetime binder in that type. If
<code class="sourceCode cpp">string_view</code> had a second named
parameter, the compiler would invent two more template lifetime
parameters: <code class="sourceCode cpp">T0<span class="fl">.0</span><span class="er">.1</span></code>
and `T1.0.1.</p>
<p>Consider the transformation when instantiating the definition of
<code class="sourceCode cpp">Pair<span class="op">&lt;</span>string_view<span class="op">/</span>a, string_view<span class="op">/</span>b<span class="op">&gt;</span></code>:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Pair<span class="op">/(</span>T0<span class="fl">.0</span><span class="er">.0</span>, T1<span class="fl">.0</span><span class="er">.0</span><span class="op">)&lt;</span>string_view<span class="op">/</span>T0<span class="fl">.0</span><span class="er">.0</span>, string_view<span class="op">/</span>T1<span class="fl">.0</span><span class="er">.0</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>  string_view<span class="op">/</span>T0<span class="fl">.0</span><span class="er">.0</span> first;</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>  string_view<span class="op">/</span>T1<span class="fl">.0</span><span class="er">.0</span> second;</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>The compiler ignores the lifetime arguments
<code class="sourceCode cpp"><span class="op">/</span>a</code> and
<code class="sourceCode cpp"><span class="op">/</span>b</code> and
replaces them with the template lifetime parameters <code class="sourceCode cpp">T0<span class="fl">.0</span><span class="er">.0</span></code>
and <code class="sourceCode cpp">T1<span class="fl">.0</span><span class="er">.0</span></code>.
This transformation deduplicates template instantiations. We don’t want
to instantiate class templates for every lifetime argument on a template
argument type. That would be an incredible waste of compute and result
in enormous code bloat. Those lifetime arguments don’t carry data in the
same way as integer or string types do. Instead, lifetime arguments
define constraints on region variables between different function
parameters and result objects. Those constraints are an external concern
to the class template being specialized.</p>
<p>Since we replaced the named lifetime arguments with template lifetime
parameters during specialization of Pair, you have to wonder, what
happened to
<code class="sourceCode cpp"><span class="op">/</span>a</code> and
<code class="sourceCode cpp"><span class="op">/</span>b</code>? They get
stuck on the outside of the class template specialization: <code class="sourceCode cpp">Pair<span class="op">&lt;</span>string_view, string_view<span class="op">&gt;/</span>a<span class="op">/</span>b</code>.
Since this specialized Pair has two lifetime binders (its two template
lifetime parameters), it needs to bind two lifetime arguments. Safe C++
replaces lifetime arguments on template arguments with invented template
lifetime parameters and reattaches the lifetime arguments on the
specialization.</p>
<p>A class template’s instantiation doesn’t depend on the lifetimes of
its users. <code class="sourceCode cpp">std2<span class="op">::</span>vector<span class="op">&lt;</span>string_view<span class="op">/</span>a<span class="op">&gt;</span></code>
is transformed to <code class="sourceCode cpp">std2<span class="op">::</span>vector<span class="op">&lt;</span>string_view<span class="op">/</span>T0<span class="fl">.0</span><span class="er">.0</span><span class="op">&gt;/</span>a</code>.
<code class="sourceCode cpp">T0<span class="fl">.0</span><span class="er">.0</span></code>
is the implicitly declared lifetime parameter, which becomes the
lifetime argument on the template argument, and
<code class="sourceCode cpp"><span class="op">/</span>a</code> is the
user’s lifetime argument that was hoisted out of the
<em>template-argument-list</em> and put in the corresponding position in
the specialization’s <em>lifetime-argument-list</em>.</p>
<p>In the current safety model, this transformation only occurs for
bound lifetime template parameters with the <code class="sourceCode cpp"><span class="kw">typename</span> T<span class="op">+</span></code>
syntax. It’s not done for all template parameters, because that would
interfere with C++’s partial and explicit specialization facilities.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T0, <span class="kw">typename</span> T1<span class="op">&gt;</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> is_same <span class="op">{</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value <span class="op">=</span> <span class="kw">false</span>;</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> is_same<span class="op">&lt;</span>T, T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value <span class="op">=</span> <span class="kw">true</span>;</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>Should <code class="sourceCode cpp">std<span class="op">::</span>is_same<span class="op">&lt;</span>string_view, string_view<span class="op">&gt;::</span>value</code>
be true or false? Of course it should be true. But if we invent template
lifetime parameters for each lifetime binder in the
<em>template-argument-list</em>, we’d get something like <code class="sourceCode cpp">std<span class="op">::</span>is_same<span class="op">&lt;</span>string_view<span class="op">/</span>T0<span class="fl">.0</span><span class="er">.0</span>, string_view<span class="op">/</span>T1<span class="fl">.0</span><span class="er">.0</span><span class="op">&gt;::</span>value</code>.
Those arguments are different types, and they wouldn’t match the partial
specialization.</p>
<p>When specializing a
<code class="sourceCode cpp"><span class="kw">typename</span> T</code>
template parameter, lifetimes are stripped from the template argument
types. They become unbound types. When specializing a <code class="sourceCode cpp"><span class="kw">typename</span> T<span class="op">+</span></code>
parameter, the compiler creates fully-bound types by implicitly adding
placeholder arguments
<code class="sourceCode cpp"><span class="op">/</span>_</code> whenever
needed. When a template specialization is matched, the lifetime
arguments are replaced with the specialization’s invented template
lifetime parameters and he original lifetime arguments are hoisted onto
the specialization.</p>
<p>You might want to think of this process as extending an electrical
circuit. The lifetime parameters outside of the class template are the
source, and the usage on the template arguments are the return. When we
specialize, the invented template lifetime parameters become a new
source, and their use as lifetime arguments in the data members of the
specialization are a new return. The old circuit is connected to the new
one, where the outer lifetime arguments lead into the new template
lifetime parameters.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>Foo&lt;string_view/a&gt;</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>  Source: /a</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>  Return: string_view</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>transforms to:</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>Foo&lt;string_view:string_view/Foo&gt;</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>  Source: /a</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>  Return: Foo (user-facing)</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>  Source: Foo (definition-facing)</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>  Return: string_view</span></code></pre></div>
<p>Because Rust doesn’t support partial or explicit specialization of
its generics, it has no corresponding distinction between type
parameters that bind lifetimes and type parameters don’t. There’s
nothing like <code class="sourceCode cpp">is_same</code> that would be
confused by lifetime arguments in its operands.</p>
<p>Deciding when to use the <code class="sourceCode cpp"><span class="kw">typename</span> T<span class="op">+</span></code>
parameter kind on class templates will hopefully be straight-forward. If
the class template is a container and the parameter represents a thing
being contained, use the new syntax. If the class template exists for
metaprogramming, like the classes found in <code class="sourceCode cpp"><span class="op">&lt;</span>type_traits<span class="op">&gt;</span></code>,
it’s probably uninterested in bound lifetimes. Use the traditional
<code class="sourceCode cpp"><span class="kw">typename</span> T</code>
parameter kind.</p>
<p>The mechanism for generating template lifetime parameters feels
right, but its presentation to the user is still in flux. An alternative
treatment would optionally permit bound lifetimes in
<code class="sourceCode cpp"><span class="kw">typename</span> T</code>
template parameters, but require users to explicitly bind a placeholder
lifetime argument
<code class="sourceCode cpp"><span class="op">/</span>_</code> if they
want bound types:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Types are unbound</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">^</span>, <span class="dt">int</span><span class="op">^&gt;</span> <span class="op">==</span> <span class="kw">true</span><span class="op">)</span>;</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Template arguments have bound placeholder lifetimes. These get replaced</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="co">// with template lifetime parameters, and the resulting types compare</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a><span class="co">// differently.</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">^/</span>_, <span class="dt">int</span><span class="op">^/</span>_<span class="op">&gt;</span> <span class="op">==</span> <span class="kw">false</span><span class="op">)</span>;</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Obj <span class="op">{</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Ill-formed if T has bound lifetimes.</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_same_v<span class="op">&lt;</span>T, <span class="dt">int</span><span class="op">^&gt;)</span>;    <span class="co">// #1</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// /0 strips lifetime arguments from types.</span></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>std<span class="op">::</span>is_same_v<span class="op">&lt;</span>T<span class="op">/</span><span class="dv">0</span>, <span class="dt">int</span><span class="op">^&gt;)</span>;  <span class="co">// #2</span></span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>Obj<span class="op">&lt;</span><span class="dt">int</span><span class="op">^/</span>_<span class="op">&gt;</span> obj1;  <span class="co">// Ill-formed at #1. Well-formed at #2.</span></span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>Obj<span class="op">&lt;</span><span class="dt">int</span><span class="op">^&gt;</span>   obj2;  <span class="co">// Well-formed at #1 and #2.</span></span></code></pre></div>
<h3 data-number="2.2.13" id="lifetime-normalization"><span class="header-section-number">2.2.13</span> Lifetime normalization<a href="#lifetime-normalization" class="self-link"></a></h3>
<p>Lifetime normalization conditions the lifetime parameters and
lifetime arguments on function declarations and function types. After
normalization, function parameters and return types have fully bound
lifetimes. Their lifetime arguments always refer to lifetime parameters
on the function, and not to those on any other scope, such as the
containing class.</p>
<p><em>Lifetime elision</em> assigns lifetime arguments to function
parameters and return types with unbound lifetimes. * If the type with
unbound lifetimes is the enclosing class of a member function, the
lifetime parameters of the enclosing class are used for elision. * If a
function parameter has unbound lifetimes, <em>elision lifetime
parameters</em> are invented to fully bind the function parameter. * If
a return type has unbound lifetimes and there is a
<code class="sourceCode cpp">self</code> parameter, it is assigned the
lifetime argument on the <code class="sourceCode cpp">self</code>
parameter, if there is just one, or elision is ill-formed. * If a return
type has unbound lifetimes and there is one lifetime parameter for the
whole function, the return type is assigned that, or elision is
ill-formed.</p>
<p>In addition to elision, lifetime normalization substitutes type
parameters in <em>outlives-constraints</em> with all corresponding
lifetime arguments of the template arguments.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T1, <span class="kw">typename</span> T2, <span class="kw">typename</span> T3<span class="op">&gt;</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> func<span class="op">/(</span>where T1<span class="op">:</span><span class="kw">static</span>, T2<span class="op">:</span>T3<span class="op">)(</span>T1 x, T2 y, T3 Z<span class="op">)</span>;</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="op">&amp;</span>func<span class="op">&lt;</span><span class="dt">int</span><span class="op">^</span>, <span class="kw">const</span> string_view<span class="op">^</span>, <span class="dt">double</span><span class="op">&gt;</span>;</span></code></pre></div>
<p>During normalization of this function specialization, the
<em>outlives-constraint</em> is rebuilt with the substituted lifetime
arguments on its type parameters. The template lifetime parameter on
<code class="sourceCode cpp"><span class="dt">int</span><span class="op">^</span></code>
outlives <code class="sourceCode cpp"><span class="op">/</span><span class="kw">static</span></code>.
All lifetime parameters bound on <code class="sourceCode cpp"><span class="kw">const</span> string_view<span class="op">^</span></code>
(one for the outer borrow, one on the string_view) outlive all lifetime
parameters bound on the
<code class="sourceCode cpp"><span class="dt">double</span></code>. But
<code class="sourceCode cpp"><span class="dt">double</span></code> isn’t
a lifetime binder. As it contributes no lifetime parameters, so the
<code class="sourceCode cpp">T2<span class="op">:</span>T3</code> type
constraint is dropped.</p>
<h2 data-number="2.3" id="explicit-mutation"><span class="header-section-number">2.3</span> Explicit mutation<a href="#explicit-mutation" class="self-link"></a></h2>
<p>Reference binding convention is important in the context of borrow
checking. Const and non-const borrows differ by more than just
constness. By the law of exclusivity, users are allowed multiple live
shared borrows, but only one live mutable borrow. C++’s convention of
always preferring non-const references would tie the borrow checker into
knots, as mutable borrows don’t permit aliasing. This is one reason why
there’s no way to borrow check existing C++ code: the standard
conversion contributes to mutable aliasing.</p>
<p>Unlike in Standard C++, expressions can have reference types. Naming
a reference object yields an lvalue expression with reference type,
rather than implicitly dereferencing the reference and giving you an
lvalue to the pointed-at thing. Since dereferencing legacy references is
unsafe, if references were implicitly dereferenced, you’d never be able
to use them in safe contexts. In Safe C++, references are more like
pointers, and passed around in safe contexts, but not dereferenced.</p>
<p>Rather than binding the mutable overload of functions by default,
Safe C++ prefers binding const overloads. Shared borrows are less likely
to bring borrow checker errors. To improve reference binding precision,
the relocation object model takes a new approach to references. The
standard conversion will bind const borrows and const lvalue references
to lvalues of the same type. But standard conversions won’t bind mutable
borrows and mutable lvalue references. Those require an opt-in.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Obj <span class="op">{</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> <span class="dt">int</span><span class="op">&amp;</span> func<span class="op">()</span> <span class="kw">const</span>;   <span class="co">// #1</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">&amp;</span> func<span class="op">()</span>;         <span class="co">// #2</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> func<span class="op">(</span>Obj obj<span class="op">)</span> <span class="op">{</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// In ISO C++, calls overload #2.</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// In Safe C++, calls overload #1.</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>  obj<span class="op">.</span>func<span class="op">()</span>;</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// In Safe C++, these all call overload #2.</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">(&amp;</span>obj<span class="op">).</span>func<span class="op">()</span>;</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>  obj<span class="op">&amp;.</span>func<span class="op">()</span>;</span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>  mut obj<span class="op">.</span>func<span class="op">()</span>;</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In Safe C++, the standard conversion will not bind a mutable borrow
or mutable lvarue reference. During overload resolution for <code class="sourceCode cpp">obj<span class="op">.</span>func<span class="op">()</span></code>,
candidate #2 fails, because the compiler can’t bind the object parameter
type
<code class="sourceCode cpp">Obj<span class="op">&amp;</span></code> to
the object expression <code class="sourceCode cpp">lvalue Obj</code>.
But candidate #1 is viable, because the standard conversion can still
bind the object parameter type <code class="sourceCode cpp"><span class="kw">const</span> Obj<span class="op">&amp;</span></code>
to the object expression
<code class="sourceCode cpp">lvalue Obj</code>.</p>
<p>The subsequent statements call candidate #1 by explicitly requesting
mutation.
<code class="sourceCode cpp"><span class="op">&amp;</span>obj</code> is
syntax for creating a <code class="sourceCode cpp">prvalue Obj<span class="op">&amp;</span></code>
from the <code class="sourceCode cpp">lvalue Obj</code> operand. We can
call the func member function on that reference. <code class="sourceCode cpp">obj<span class="op">&amp;.</span>func<span class="op">()</span></code>
uses a special postfix syntax that alleviates the need for parentheses.
Finally, the <code class="sourceCode cpp">mut</code> keyword puts the
remaining operators of the <em>cast-expression</em> into the <a href="#the-mutable-context"><em>mutable context</em></a>. In the mutable
context, standard conversions to mutable borrows and mutable lvalue
references are enabled. Overload resolution finds both candidates #1 and
#2 viable, and chooses #2 because the mutable lvalue reference ranks
higher than the const reference.</p>
<p>Here’s a list of <em>unary-operators</em> for taking borrows, lvalue
and rvalue references, and pointers to lvalues.</p>
<ul>
<li><code class="sourceCode cpp"><span class="op">^</span>x</code> -
mutable borrow to <code class="sourceCode cpp">x</code></li>
<li><code class="sourceCode cpp"><span class="op">^</span><span class="kw">const</span> x</code>
- shared borrow to <code class="sourceCode cpp">x</code></li>
<li><code class="sourceCode cpp"><span class="op">&amp;</span>x</code> -
lvalue reference to <code class="sourceCode cpp">x</code> (convertible
to pointer)</li>
<li><code class="sourceCode cpp"><span class="op">&amp;</span><span class="kw">const</span> x</code>
- const lvalue reference to <code class="sourceCode cpp">x</code></li>
<li><code class="sourceCode cpp"><span class="op">&amp;&amp;</span>x</code>
- rvalue reference to <code class="sourceCode cpp">x</code></li>
<li><code class="sourceCode cpp">addr x</code> - pointer to
<code class="sourceCode cpp">x</code></li>
<li><code class="sourceCode cpp">addr <span class="kw">const</span> x</code>
- const pointer to <code class="sourceCode cpp">x</code></li>
</ul>
<p>While the motivation of this design is to pacify the borrow checker,
the consequence is that <strong>all mutations are explicit</strong>. You
don’t have to wonder about side-effects. If you’re passing arguments to
a function, and you don’t see <code class="sourceCode cpp">mut</code>,
<code class="sourceCode cpp"><span class="op">^</span></code>,
<code class="sourceCode cpp"><span class="op">&amp;</span></code> or
<code class="sourceCode cpp"><span class="op">&amp;&amp;</span></code>
before it, you know the argument won’t be modified by that function.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1<span class="op">(</span><span class="dt">int</span><span class="op">^)</span>;</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f2<span class="op">(</span><span class="kw">const</span> <span class="dt">int</span><span class="op">^)</span>;</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f3<span class="op">(</span><span class="dt">int</span><span class="op">&amp;)</span>;</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f4<span class="op">(</span><span class="kw">const</span> <span class="dt">int</span><span class="op">&amp;)</span>;</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f5<span class="op">(</span><span class="dt">int</span><span class="op">&amp;&amp;)</span>;</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x <span class="op">=</span> <span class="dv">1</span>;</span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Explicit ^ for mut borrow required.</span></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>  f1<span class="op">(^</span>x<span class="op">)</span>;</span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>  f1<span class="op">(</span>mut x<span class="op">)</span>;</span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Standard conversion or explicit ^const for shared borrow.</span></span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a>  f2<span class="op">(</span>x<span class="op">)</span>;</span>
<span id="cb62-21"><a href="#cb62-21" aria-hidden="true" tabindex="-1"></a>  f2<span class="op">(^</span><span class="kw">const</span> x<span class="op">)</span>;</span>
<span id="cb62-22"><a href="#cb62-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-23"><a href="#cb62-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Explicit &amp; for lvalue ref required.</span></span>
<span id="cb62-24"><a href="#cb62-24" aria-hidden="true" tabindex="-1"></a>  f3<span class="op">(&amp;</span>x<span class="op">)</span>;</span>
<span id="cb62-25"><a href="#cb62-25" aria-hidden="true" tabindex="-1"></a>  f3<span class="op">(</span>mut x<span class="op">)</span>;</span>
<span id="cb62-26"><a href="#cb62-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-27"><a href="#cb62-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Standard conversion or explicit &amp;const for const lvalue ref.</span></span>
<span id="cb62-28"><a href="#cb62-28" aria-hidden="true" tabindex="-1"></a>  f4<span class="op">(</span>x<span class="op">)</span>;</span>
<span id="cb62-29"><a href="#cb62-29" aria-hidden="true" tabindex="-1"></a>  f4<span class="op">(&amp;</span><span class="kw">const</span> x<span class="op">)</span>;</span>
<span id="cb62-30"><a href="#cb62-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-31"><a href="#cb62-31" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Explicit rvalue ref.</span></span>
<span id="cb62-32"><a href="#cb62-32" aria-hidden="true" tabindex="-1"></a>  f5<span class="op">(&amp;&amp;</span>x<span class="op">)</span>;</span>
<span id="cb62-33"><a href="#cb62-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-34"><a href="#cb62-34" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Explicit &amp; for non-const lvalue reference operands.</span></span>
<span id="cb62-35"><a href="#cb62-35" aria-hidden="true" tabindex="-1"></a>  <span class="op">&amp;</span>std<span class="op">::</span>cout<span class="op">&lt;&lt;</span> <span class="st">&quot;Hello mutation</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb62-36"><a href="#cb62-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In Rust, types and declarations are const by default. In C++, they’re
mutable by default. But by supporting standard conversions to const
references, reference binding in Safe C++ is less noisy than the Rust
equivalent, while being no less precise.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Rust:</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>f<span class="op">(&amp;</span>mut x<span class="op">)</span>;    <span class="co">// Pass by mutable borrow.</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>f<span class="op">(&amp;</span>x<span class="op">)</span>;        <span class="co">// Pass by shared borrow.</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a><span class="co">// C++:</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>f<span class="op">(^</span>x<span class="op">)</span>;        <span class="co">// Pass by mutable borrow.</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span>x<span class="op">)</span>;         <span class="co">// Pass by shared borrow.</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>f<span class="op">(^</span><span class="kw">const</span> x<span class="op">)</span>;  <span class="co">// Extra verbose -- call attention to it.</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>f<span class="op">(&amp;</span>x<span class="op">)</span>;        <span class="co">// Pass by mutable lvalue ref.</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span>x<span class="op">)</span>;         <span class="co">// Pass by const lvalue ref.</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>f<span class="op">(&amp;</span><span class="kw">const</span> x<span class="op">)</span>;  <span class="co">// Extra verbose -- call attention to it.</span></span></code></pre></div>
<p>The availability of relocation forces another choice on users: to
load an lvalue into a prvalue, do you want to copy, or do you want to
relocate? If the expression’s type is trivially copyable and trivially
destructible, it’ll copy. Otherwise, the compiler will prompt for a
<code class="sourceCode cpp">rel</code> or
<code class="sourceCode cpp">cpy</code> token to resolve how to resolve
the copy initialization. You’re not going to accidentally hit the slow
path or the mutable path. Opt into mutation. Opt into no-trivial
copies.</p>
<h3 data-number="2.3.1" id="the-mutable-context"><span class="header-section-number">2.3.1</span> The mutable context<a href="#the-mutable-context" class="self-link"></a></h3>
<p>The mutable context is the preferred way to express mutation. In a
sense it returns Safe C++ to legacy C++’s default binding behavior. Use
it at the start of a <em>cast-expression</em>, and the mutable context
lasts for all subsequent higher-precedence operations. In the mutable
context, standard conversion may bind mutable borrows and mutable lvalue
references to lvalue operands.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>  std2<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">size_t</span><span class="op">&gt;</span> A <span class="op">{</span> <span class="op">}</span>, B <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Get a shared borrow to an element in B.</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The borrow is live until it is loaded from below.</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> <span class="dt">size_t</span><span class="op">^</span> b <span class="op">=</span> B<span class="op">[</span><span class="dv">0</span><span class="op">]</span>;</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// A[0] is in the mutable context, so A[0] is the mutable operator[].</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// B[0] is outside the mutable context, so B[0] is the const operator[].</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// No borrow checking error.</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>  mut A<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">+=</span> B<span class="op">[</span><span class="dv">0</span><span class="op">]</span>;</span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Mutable context allows standard conversion binding of mut references.</span></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span><span class="op">^</span> a <span class="op">=</span> mut A<span class="op">[</span><span class="dv">0</span><span class="op">]</span>;</span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Keep b live.</span></span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> x <span class="op">=</span> <span class="op">*</span>b;</span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Write the <code class="sourceCode cpp">mut</code> token before the
<em>cast-expression</em> you want to mutate. <em>cast-expressions</em>
are high-precedence unary expressions. Lower-precedence binary
expressions aren’t in the scope of the mutable context. In this example,
the mutable context applies only to the left-hand side of the
assignment. <code class="sourceCode cpp">A<span class="op">[</span><span class="dv">0</span><span class="op">]</span></code>
chooses the mutable overload of <code class="sourceCode cpp">vector<span class="op">::</span><span class="kw">operator</span><span class="op">[]</span></code>,
and <code class="sourceCode cpp">B<span class="op">[</span><span class="dv">0</span><span class="op">]</span></code>
chooses the const overload of <code class="sourceCode cpp">vector<span class="op">::</span><span class="kw">operator</span><span class="op">[]</span></code>.
This confirmed by the lack of borrow checker error: if the <code class="sourceCode cpp">B<span class="op">[</span><span class="dv">0</span><span class="op">]</span></code>
expression chose the mutable overload, that would create a mutable
borrow when the shared borrow <code class="sourceCode cpp">b</code> is
still in scope, which violates exclusivity. In the following statement,
<code class="sourceCode cpp"><span class="dt">int</span><span class="op">^</span> a <span class="op">=</span> mut A<span class="op">[</span><span class="dv">0</span><span class="op">]</span></code>
calls the mutable overload of the subscript operator, returning an
<code class="sourceCode cpp">lvalue <span class="dt">int</span></code>
expression. We’re still in the mutable context, because we haven’t run
into any operators of lower precedence. That means copy initialization
into <code class="sourceCode cpp"><span class="dt">int</span><span class="op">^</span></code>
succeeds, because the standard conversion can bind mutable borrows to
lvalues.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>  std2<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">size_t</span><span class="op">&gt;</span> A <span class="op">{</span> <span class="op">}</span>, B <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Get a shared borrow to an element in B.</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The borrow is live until it is loaded from below.</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> <span class="dt">size_t</span><span class="op">^</span> b <span class="op">=</span> B<span class="op">[</span><span class="dv">0</span><span class="op">]</span>;</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// A is in the mutable context for its operator[] call.</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// B is not in the mutable conetxt for its operator[] call.</span></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// No borrow checker error.</span></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>  mut A<span class="op">[</span>B<span class="op">[</span><span class="dv">0</span><span class="op">]]</span> <span class="op">+=</span> <span class="dv">1</span>;</span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Keep b live.</span></span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> x <span class="op">=</span> <span class="op">*</span>b;</span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The mutable context is entered at the start of a
<em>cast-expression</em> with the
<code class="sourceCode cpp">mut</code> token. It exists for subsequent
high-precedence <em>unary-expression</em>, <em>postfix-expression</em>
and <em>primary-expression</em> operations. But it’s transitive into
subexpressions of these. The index operand of the subscript operator
matches the <em>expression-list</em> production, which is lower
precedence than <em>cast-expression</em>, so it’s not entered with the
mutable context.</p>
<p>The mutable context marks points of mutation while letting standand
conversion worry about the details. Its intent is to reduce cognitive
load on developers compared with using the reference operators.</p>
<h2 data-number="2.4" id="relocation-object-model"><span class="header-section-number">2.4</span> Relocation object model<a href="#relocation-object-model" class="self-link"></a></h2>
<p>A core enabling feature of Safe C++ is the new object model. It
supports relocation/destructive move of local objects, which is
necessary for satisfying type safety. Additionally, <em>all mutations
are explicit</em>. This is nice in its own right, but it’s really
important for distinguishing between mutable and shared borrows.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// No default construct. p is uninitialized.</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>  std2<span class="op">::</span>box<span class="op">&lt;</span>string<span class="op">&gt;</span> p;</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Ill-formed: p is uninitialized.</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(*</span>p<span class="op">)</span>;</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>$ circle unique1.cxx</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>safety: unique1.cxx:11:12</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  println(*p);</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>           ^</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>cannot use uninitialized object p</span></code></pre></div>
<p>The
<code class="sourceCode cpp">std2<span class="op">::</span>box</code>
has no default state. It’s safe against <a href="#type-safety">null
pointer type safety bugs</a>. A <code class="sourceCode cpp">box</code>
that’s declared without a constructor is not default initialized. It’s
uninitialized. It’s illegal to use until it’s been assigned to.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std2;</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span>box<span class="op">&lt;</span>string<span class="op">&gt;</span> p<span class="op">)</span> safe <span class="op">{</span> <span class="op">}</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// No default construct. p is uninitialized.</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>  box<span class="op">&lt;</span>string<span class="op">&gt;</span> p;</span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>  p <span class="op">=</span> box<span class="op">&lt;</span>string<span class="op">&gt;(</span><span class="st">&quot;Hello&quot;</span><span class="op">)</span>;</span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(*</span>p<span class="op">)</span>;</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Relocate to another function.</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>  f<span class="op">(</span>rel p<span class="op">)</span>;</span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Ill-formed: p is uninitialized.</span></span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(*</span>p<span class="op">)</span>;</span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>$ circle unique2.cxx</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>safety: unique2.cxx:18:12</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  println(*p);  // Ill-formed.</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>           ^</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>cannot use uninitialized object p</span></code></pre></div>
<p>Once we assign to <code class="sourceCode cpp">p</code>, we can use
it. But we can’t
<code class="sourceCode cpp">std<span class="op">::</span>move</code>
into another function, because move semantics put the operand into its
default state, and we’re stipulating that the box has no default state.
Fortunately, the new object model provides for <em>relocation</em>,
which moves the contents of the object into a value, and sets the source
to uninitialized. The destructor on the old object never gets run,
because that old declaration no longer owns the object. Ownership has
changed with the relocation.</p>
<p>It’s a feature, not a defect, that the compiler errors when you use
an uninitialized or potentially uninitialized object. The alternative is
a type safety error, such as a null pointer dereference undefined
behavior.</p>
<p>In Rust, objects are <em>relocated by default</em>, unless they
implement the <code class="sourceCode cpp">Copy</code> trait,<span class="citation" data-cites="copy-trait">[<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html" role="doc-biblioref">copy-trait</a>]</span> in which case they’re
copied. If you want to copy a non-Copy object, implement the
<code class="sourceCode cpp">Clone</code> trait<span class="citation" data-cites="clone-trait">[<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html" role="doc-biblioref">clone-trait</a>]</span> and call the
<code class="sourceCode cpp">clone</code> member function.</p>
<p>I think implicit relocation is too surprising for C++ users. We’re
more likely to have raw pointers and legacy references tracking objects,
and you don’t want to pull the storage out from under them, at least not
without some clear token in the source code. That’s why Safe C++
includes <em>rel-expression</em> and <em>cpy-expression</em>.</p>
<ul>
<li><code class="sourceCode cpp">rel x</code> - relocate
<code class="sourceCode cpp">x</code> into a new value.
<code class="sourceCode cpp">x</code> is set as uninitialized.</li>
<li><code class="sourceCode cpp">cpy x</code> - copy construct
<code class="sourceCode cpp">x</code> into a new value.
<code class="sourceCode cpp">x</code> remains initialized.</li>
</ul>
<p>Why make copy and relocation explicit? In line with C++’s goals of
<em>zero-cost abstractions</em>, we want to make it easy for users to
choose the more efficient option. If a type is not trivially copyable,
you can opt into an expensive copy with <em>cpy-expression</em>. This
avoids performance bugs, where an object undergoes an expensive copy
just because the user didn’t know it was there. Or, if you don’t want to
copy, use <em>rel-expression</em>, which is efficient but destroys the
old object, without destructing it.</p>
<p>If an object is <em>trivially copyable</em>, as all scalar types are,
then you don’t need either of these tokens. The compiler will copy your
value without prompting.</p>
<p>The relocation object model also supports <em>drp-expression</em>,
noted by the <code class="sourceCode cpp">drp</code> token, which calls
the destructor on an object and leaves it uninitialized. See the <a href="#destructors-and-phantom-data">Destructors and phantom data</a>
for details.</p>
<p>Consider a function like <code class="sourceCode cpp">std<span class="op">::</span>unique_ptr<span class="op">::</span>reset</code>.
It destructs the existing object, if one is engaged, and sets the
unique_ptr to its null state. But in our safe version, box doesn’t have
a default state. It doesn’t supply the
<code class="sourceCode cpp">reset</code> member function. Instead,
users just drop it, running its destructor and leaving it
uninitialized.</p>
<p>You’ve noticed the nonsense spellings for these keywords. Why not
call them <code class="sourceCode cpp">move</code>,
<code class="sourceCode cpp">copy</code> and
<code class="sourceCode cpp">drop</code>? Alternative token spelling
avoids shadowing these common identifiers and improves results when
searching code or the web.</p>
<h3 data-number="2.4.1" id="tuples-arrays-and-slices"><span class="header-section-number">2.4.1</span> Tuples, arrays and slices<a href="#tuples-arrays-and-slices" class="self-link"></a></h3>
<p>Using an uninitialized or potentially uninitialized object raises a
compile-time error. But initialization analysis only accounts for the
state of local variables that are directly named and not part of a
dereference. Local objects and their subobjects are <em>owned
places</em>. Initialization analysis allocates flags for owned places,
so that it can track their initialization status and error when there’s
a use of a place that’s <em>definitely initialized</em>. It’s not
possible for the compiler to chase through references and function calls
to find initialization data for objects potentially owned by other
functions.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/rel1.cxx"><strong>rel1.cxx</strong></a>
– <a href="https://godbolt.org/z/8nGo59E1v">(Compiler Explorer)</a></p>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;tuple&gt;</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Pair <span class="op">{</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x, y;</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>Pair g <span class="op">{</span> <span class="dv">10</span>, <span class="dv">20</span> <span class="op">}</span>;</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Relocate from an std::tuple element.</span></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> tup <span class="op">=</span> std<span class="op">::</span>make_tuple<span class="op">(</span><span class="dv">5</span>, <span class="fl">1.619</span><span class="op">)</span>;</span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x <span class="op">=</span> rel <span class="op">*</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(&amp;</span>tup<span class="op">)</span>;</span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Relocate from runtime subscript.</span></span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> data<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> index <span class="op">=</span> <span class="dv">1</span>;</span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> y <span class="op">=</span> rel data<span class="op">[</span>index<span class="op">]</span>;</span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Relocate from subobject of a global.</span></span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> gy <span class="op">=</span> rel g<span class="op">.</span>y;</span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>$ circle rel1.cxx</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>safety: rel1.cxx:13:15</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  int x = rel *get&lt;0&gt;(&amp;tup);</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>              ^</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>rel operand does not refer to an owned place</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>an owned place is a local variable or subobject of a local variable</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>the place involves a dereference of int&amp;</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>safety: rel1.cxx:18:19</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  int y = rel data[index];</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>                  ^</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>rel operand does not refer to an owned place</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>an owned place is a local variable or subobject of a local variable</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>the place involves a subscript of int[5]</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>safety: rel1.cxx:21:17</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>  int gy = rel g.y;</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>                ^</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>rel operand does not refer to an owned place</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>an owned place is a local variable or subobject of a local variable</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>g is a non-local variable declared at rel1.cxx:8:6</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>Pair g { 10, 20 };</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>     ^</span></code></pre></div>
<p>This example demonstrates that you can’t relocate through the
reference returned from
<code class="sourceCode cpp">std<span class="op">::</span>get</code>.
You can’t relocate through a dynamic subscript of an array. You can’t
relocate the subobject of a global variable. You can only relocate or
drop <em>owned places</em>.</p>
<p>If we can’t relocate through a reference, how do we relocate through
elements of
<code class="sourceCode cpp">std<span class="op">::</span>tuple</code>,
<code class="sourceCode cpp">std<span class="op">::</span>array</code>
or
<code class="sourceCode cpp">std<span class="op">::</span>variant</code>?
Unless those become magic types with special compiler support, you
can’t. Those standard containers only provide access to their elements
through accessor functions. But initialization analysis only considers
the definition of the current function; it doesn’t leap into other
functions, because that’s on the slippery slope to whole-program
analysis.</p>
<p>We address the defects in C++’s algebraic types by including new
first-class tuple, array and <a href="#choice-types">choice</a> types.
Safe C++ is still compatible with legacy types, but due to their
non-local element access, relocation from their subobjects is not
feasible. Relocation is important to type safety, because many types
prohibit default states, making C++-style move semantics impossible.
Either relocate your object, or put it in an
<code class="sourceCode cpp">optional</code> from which it can be
unwrapped.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/tuple1.cxx"><strong>tuple1.cxx</strong></a>
– <a href="https://godbolt.org/z/4hq7Eb86x">(Compiler Explorer)</a></p>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span><span class="pp">          </span><span class="co">// Pull in the definition of std2::tuple.</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> T0 <span class="op">=</span> <span class="op">()</span>;             <span class="co">// Zero-length tuple type.</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> T1 <span class="op">=</span> <span class="op">(</span><span class="dt">int</span>, <span class="op">)</span>;        <span class="co">// One-length tuple type.</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> T2 <span class="op">=</span> <span class="op">(</span><span class="dt">int</span>, <span class="dt">double</span><span class="op">)</span>;  <span class="co">// Longer tuples type.</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Nest at your leisure.</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> T3 <span class="op">=</span> <span class="op">(((</span><span class="dt">int</span>, <span class="dt">double</span><span class="op">)</span>, <span class="dt">float</span><span class="op">)</span>, <span class="dt">char</span><span class="op">)</span>;</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Zero-length tuple expression.</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> t0 <span class="op">=</span> <span class="op">(</span>,<span class="op">)</span>;</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>T0 <span class="op">==</span> <span class="kw">decltype</span><span class="op">(</span>t0<span class="op">))</span>;</span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// One-length tuple expression.</span></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> t1 <span class="op">=</span> <span class="op">(</span><span class="dv">4</span>, <span class="op">)</span>;</span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>T1 <span class="op">==</span> <span class="kw">decltype</span><span class="op">(</span>t1<span class="op">))</span>;</span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>     </span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Longer tuple expression.</span></span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> t2 <span class="op">=</span> <span class="op">(</span><span class="dv">5</span>, <span class="fl">3.14</span><span class="op">)</span>;</span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>T2 <span class="op">==</span> <span class="kw">decltype</span><span class="op">(</span>t2<span class="op">))</span>;</span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Nest tuples.</span></span>
<span id="cb69-25"><a href="#cb69-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> t3 <span class="op">=</span> <span class="op">(((</span><span class="dv">1</span>, <span class="fl">1.618</span><span class="op">)</span>, <span class="fl">3.3</span><span class="bu">f</span><span class="op">)</span>, <span class="ch">&#39;T&#39;</span><span class="op">)</span>;</span>
<span id="cb69-26"><a href="#cb69-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>T3 <span class="op">==</span> <span class="kw">decltype</span><span class="op">(</span>t3<span class="op">))</span>;</span>
<span id="cb69-27"><a href="#cb69-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-28"><a href="#cb69-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Access the 1.618 double field:</span></span>
<span id="cb69-29"><a href="#cb69-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> x <span class="op">=</span> t3<span class="fl">.0</span><span class="er">.0</span><span class="fl">.1</span>;</span>
<span id="cb69-30"><a href="#cb69-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span><span class="dt">double</span> <span class="op">==</span> <span class="kw">decltype</span><span class="op">(</span>x<span class="op">))</span>;</span>
<span id="cb69-31"><a href="#cb69-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The new first-class tuple type is syntaxed with comma-separated lists
of types inside parentheses. Tuple expressions are noted with
comma-separated lists of expressions inside parentheses. You can nest
them. You can access elements of tuple expressions by chaining indices
together with dots. Tuple fields are accessed with the customary special
tuple syntax: just write the element index after a dot, eg
<code class="sourceCode cpp">tup<span class="fl">.0</span></code>.</p>
<p>Use <code class="sourceCode cpp">circle <span class="op">-</span>print<span class="op">-</span>mir</code>
to dump the MIR of this program.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>   15  Assign _4.1 = 84</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>   16  Commit _4 (((int, double), float), char)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>   17  InstStart _5 double</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>   18  Assign _5 = use _4.0.0.1</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>   19  InstEnd _5</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>   20  InstEnd _4</span></code></pre></div>
<p>The assignment <code class="sourceCode cpp">t3<span class="fl">.0</span><span class="er">.0</span><span class="fl">.1</span></code>
lowers to <code class="sourceCode cpp">_4<span class="fl">.0</span><span class="er">.0</span><span class="fl">.1</span></code>.
This is a place name of a local variable. Importantly, it doesn’t
involve dereferences, unlike the result of an
<code class="sourceCode cpp">std<span class="op">::</span>get</code>
call. It’s an <em>owned place</em> which the compiler is able to
relocate out of.</p>
<p>C++’s native array decays to pointers and doesn’t support
pass-by-value semantics.
<code class="sourceCode cpp">std<span class="op">::</span>array</code>
encapsulates arrays to fix these problems and provides an <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">[]</span></code>
API for consistent subscripting syntax. But
<code class="sourceCode cpp">std<span class="op">::</span>array</code>
is broken for our purposes. Since <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">[]</span></code>
returns a reference, the
<code class="sourceCode cpp">std<span class="op">::</span>array</code>’s
elements are not <em>owned places</em> and can’t be relocated out
of.</p>
<p>Safe C++ introduces a first-class pass-by-value array type <code class="sourceCode cpp"><span class="op">[</span>T; N<span class="op">]</span></code>
and a first-class slice companion type <code class="sourceCode cpp"><span class="op">[</span>T; dyn<span class="op">]</span></code>.
Subobjects of both the old and new array types with constant indices are
<em>owned places</em> and support relocation.</p>
<p>Slices have dynamic length and are <em>incomplete types</em>. You may
form borrows, references or pointers to slices and access through those.
These are called <em>fat pointers</em> and are 16 bytes on 64-bit
platforms. The data pointer is accompanied by a length field.</p>
<p>The new array type, the slice type and the legacy builtin array type
panic on out-of-bounds subscripts. They exhibit bounds safety in the new
object model. Use <a href="#unsafe-subscripts">unsafe subscripts</a> to
suppress the runtime bounds check.</p>
<p>Making
<code class="sourceCode cpp">std<span class="op">::</span>pair</code>,
<code class="sourceCode cpp">std<span class="op">::</span>tuple</code>
and
<code class="sourceCode cpp">std<span class="op">::</span>array</code>
magic types with native support for relocation is on the short list of
language improvements. In the meanwhile, their first-class replacements
provide us with a convenient path forward for developing the safe
standard library.</p>
<h3 data-number="2.4.2" id="operator-rel"><span class="header-section-number">2.4.2</span>
<code class="sourceCode cpp"><span class="kw">operator</span> rel</code><a href="#operator-rel" class="self-link"></a></h3>
<p>Safe C++ introduces a new special member function, the <em>relocation
constructor</em>, written <code class="sourceCode cpp"><span class="kw">operator</span> rel<span class="op">(</span>T<span class="op">)</span></code>,
for all class types. Using the <em>rel-expression</em> invokes the
relocation constructor. The relocation constructor exists to bridge
C++11’s move semantics model with Safe C++’s relocation model.
Relocation constructors can be:</p>
<ul>
<li>User defined - manually relocate the operand into the new object.
This can be used for fixing internal addresses, like those used to
implement sentinels in standard linked lists and maps.</li>
<li><code class="sourceCode cpp"><span class="op">=</span> trivial</code>
- Trivially copyable types are already trivially relocatable. But other
types may be trivially relocatable as well, like
<code class="sourceCode cpp">box</code>,
<code class="sourceCode cpp">unique_ptr</code>,
<code class="sourceCode cpp">rc</code>,
<code class="sourceCode cpp">arc</code> and
<code class="sourceCode cpp">shared_ptr</code>.</li>
<li><code class="sourceCode cpp"><span class="op">=</span> <span class="cf">default</span></code>
- A defaulted or implicitly declared relocation constructor is
implemented by the compiler with one of three strategies: types with
safe destructors are trivially relocated; aggregate types use
member-wise relocation; and other types are move-constructed into the
new data, and the old operand is destroyed.</li>
<li><code class="sourceCode cpp"><span class="op">=</span> <span class="kw">delete</span></code>
- A deleted relocation constructor <em>pins</em> a type. Objects of that
type can’t be relocated. A <code class="sourceCode cpp">rel<span class="op">-</span>expression</code> is
a SFINAE failure. Rust uses its
<code class="sourceCode cpp">std<span class="op">::</span>Pin</code><span class="citation" data-cites="pin">[<a href="https://doc.rust-lang.org/std/pin/index.html" role="doc-biblioref">pin</a>]</span> pin type as a container for structs
with with address-sensitive states. That’s an option with Safe C++’s
deleted relocation constructors. Or, users can write user-defined
relocation constructors to update address-sensitive states.</li>
</ul>
<p>Relocation constructors are always noexcept. It’s used to implement
the drop-and-replace semantics of assignment expressions. If a
relocation constructor was throwing, it might leave objects involved in
drop-and-replace in illegal uninitialized states. An uncaught exception
in a user-defined or defaulted relocation constructor will panic and
terminate.</p>
<h2 data-number="2.5" id="choice-types"><span class="header-section-number">2.5</span> Choice types<a href="#choice-types" class="self-link"></a></h2>
<p>The new <code class="sourceCode cpp">choice</code> type is a type
safe discriminated union. It’s equivalent to Rust’s
<code class="sourceCode cpp"><span class="kw">enum</span></code> type.
Choice types contain a list of alternatives, each with an optional
payload type. Choice does not replace C++’s enum type, which is still
available to support support existing code.</p>
<p>Scoped enums and unscoped enums with fixed underlying types are
permitted to hold values outside of the listed enumerators, as long as
the value is within the range of the underlying type. But choice types
only contain the alternatives listed in their definitions, making them
easier to reason about. There’s no safe conversion between choice types
and their underlying types; programmers must use choice initializers to
create new choice objects and <em>match-expressions</em> to interrogate
them.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/choice.cxx"><strong>choice.cxx</strong></a></p>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="co">// An enum-like choice that has alternatives but no payloads.</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Unlike enums, it is not permitted to cast between C1 and its underlying</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a><span class="co">// integral type.</span></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>choice C1 <span class="op">{</span></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>  A, B, C,</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a><span class="co">// A choice type with payloads for each alternative.</span></span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>choice C2 <span class="op">{</span></span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a>  i8<span class="op">(</span><span class="dt">int8_t</span><span class="op">)</span>,</span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>  i16<span class="op">(</span><span class="dt">int16_t</span><span class="op">)</span>,</span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>  i32<span class="op">(</span><span class="dt">int32_t</span><span class="op">)</span>,</span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>  i64<span class="op">(</span><span class="dt">int64_t</span><span class="op">)</span>,</span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true" tabindex="-1"></a><span class="co">// A choice type with mixed payload and no-payload alternatives.</span></span>
<span id="cb70-19"><a href="#cb70-19" aria-hidden="true" tabindex="-1"></a>choice C3 <span class="op">{</span></span>
<span id="cb70-20"><a href="#cb70-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">// default allowed once per choice, on a no-payload alternative.</span></span>
<span id="cb70-21"><a href="#cb70-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">default</span> none,</span>
<span id="cb70-22"><a href="#cb70-22" aria-hidden="true" tabindex="-1"></a>  i<span class="op">(</span><span class="dt">int</span><span class="op">)</span>,</span>
<span id="cb70-23"><a href="#cb70-23" aria-hidden="true" tabindex="-1"></a>  f<span class="op">(</span><span class="dt">float</span><span class="op">)</span>,</span>
<span id="cb70-24"><a href="#cb70-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb70-25"><a href="#cb70-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-26"><a href="#cb70-26" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb70-27"><a href="#cb70-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">// choice-initializer uses scope resolution to name the alternative.</span></span>
<span id="cb70-28"><a href="#cb70-28" aria-hidden="true" tabindex="-1"></a>  C1 x1 <span class="op">=</span> C1<span class="op">::</span>B<span class="op">()</span>;</span>
<span id="cb70-29"><a href="#cb70-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-30"><a href="#cb70-30" aria-hidden="true" tabindex="-1"></a>  <span class="co">// abbreviated-choice-name infers the choice type from the lhs.</span></span>
<span id="cb70-31"><a href="#cb70-31" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If there&#39;s no payload type, using () is optional.</span></span>
<span id="cb70-32"><a href="#cb70-32" aria-hidden="true" tabindex="-1"></a>  C1 x2 <span class="op">=</span> <span class="op">.</span>B<span class="op">()</span>;</span>
<span id="cb70-33"><a href="#cb70-33" aria-hidden="true" tabindex="-1"></a>  C1 x3 <span class="op">=</span> <span class="op">.</span>B;</span>
<span id="cb70-34"><a href="#cb70-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-35"><a href="#cb70-35" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Create choice objects with initializers.</span></span>
<span id="cb70-36"><a href="#cb70-36" aria-hidden="true" tabindex="-1"></a>  C2 y1 <span class="op">=</span> C2<span class="op">::</span>i32<span class="op">(</span><span class="dv">55</span><span class="op">)</span>;</span>
<span id="cb70-37"><a href="#cb70-37" aria-hidden="true" tabindex="-1"></a>  C2 y2 <span class="op">=</span> <span class="op">.</span>i32<span class="op">(</span><span class="dv">55</span><span class="op">)</span>;</span>
<span id="cb70-38"><a href="#cb70-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-39"><a href="#cb70-39" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If there&#39;s a defaulted alternative, the choice type has a default</span></span>
<span id="cb70-40"><a href="#cb70-40" aria-hidden="true" tabindex="-1"></a>  <span class="co">// initializer that makes an instance with that value.</span></span>
<span id="cb70-41"><a href="#cb70-41" aria-hidden="true" tabindex="-1"></a>  C3 z1 <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb70-42"><a href="#cb70-42" aria-hidden="true" tabindex="-1"></a>  C3 z2 <span class="op">=</span> C3<span class="op">()</span>;</span>
<span id="cb70-43"><a href="#cb70-43" aria-hidden="true" tabindex="-1"></a>  C3 z3 <span class="op">=</span> C3<span class="op">::</span>none<span class="op">()</span>;</span>
<span id="cb70-44"><a href="#cb70-44" aria-hidden="true" tabindex="-1"></a>  C3 z4 <span class="op">=</span> <span class="op">.</span>none;</span>
<span id="cb70-45"><a href="#cb70-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Rust uses traits to extend data types with new member functions
outside of their definitions. Safe C++ doesn’t have that capability, so
it’s important that choice types support member functions directly.
These member functions may internalize pattern matching on their
<code class="sourceCode cpp">self</code> parameters, improving the
ergonomics of these type-safe variants.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">+,</span> <span class="kw">class</span> E<span class="op">+&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>choice expected <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">safety</span><span class="op">::</span><span class="at">unwrap</span><span class="op">]]</span> ok<span class="op">(</span>T<span class="op">),</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  err<span class="op">(</span>E<span class="op">);</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  T unwrap<span class="op">(</span>self<span class="op">)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> match<span class="op">(</span>self<span class="op">)</span> <span class="op">-&gt;</span> T <span class="op">{</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>ok<span class="op">(</span>t<span class="op">)</span>  <span class="op">=&gt;</span> rel t<span class="op">;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>err<span class="op">(</span>e<span class="op">)</span> <span class="op">=&gt;</span> panic<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st"> is err&quot;</span><span class="op">.</span>format<span class="op">(</span>expected<span class="op">~</span>string<span class="op">));</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">+&gt;</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>choice optional</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">default</span> none<span class="op">,</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">safety</span><span class="op">::</span><span class="at">unwrap</span><span class="op">]]</span> some<span class="op">(</span>T<span class="op">);</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> E<span class="op">&gt;</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>  expected<span class="op">&lt;</span>T<span class="op">,</span> E<span class="op">&gt;</span> ok_or<span class="op">(</span>self<span class="op">,</span> E e<span class="op">)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> match<span class="op">(</span>self<span class="op">)</span> <span class="op">-&gt;</span> expected<span class="op">&lt;</span>T<span class="op">,</span> E<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>some<span class="op">(</span>t<span class="op">)</span> <span class="op">=&gt;</span> <span class="op">.</span>ok<span class="op">(</span>rel t<span class="op">);</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>none    <span class="op">=&gt;</span> <span class="op">.</span>err<span class="op">(</span>rel e<span class="op">);</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>  T expect<span class="op">(</span>self<span class="op">,</span> str msg<span class="op">)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> match<span class="op">(</span>self<span class="op">)</span> <span class="op">-&gt;</span> T <span class="op">{</span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>some<span class="op">(</span>t<span class="op">)</span> <span class="op">=&gt;</span> rel t<span class="op">;</span></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>none    <span class="op">=&gt;</span> panic<span class="op">(</span>msg<span class="op">);</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>  T unwrap<span class="op">(</span>self<span class="op">)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> match<span class="op">(</span>self<span class="op">)</span> <span class="op">-&gt;</span> T <span class="op">{</span></span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>some<span class="op">(</span>t<span class="op">)</span> <span class="op">=&gt;</span> rel t<span class="op">;</span></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>none    <span class="op">=&gt;</span> panic<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st"> is none&quot;</span><span class="op">.</span>format<span class="op">(</span>optional<span class="op">~</span>string<span class="op">));</span></span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 data-number="2.5.1" id="pattern-matching"><span class="header-section-number">2.5.1</span> Pattern matching<a href="#pattern-matching" class="self-link"></a></h3>
<p>The <em>match-expression</em> in Safe C++ offers much the same
capabilities as the pattern matching implemented in C# and Swift and
proposed for C++ in <span class="citation" data-cites="P2688R1">[<a href="https://wg21.link/p2688r1" role="doc-biblioref">P2688R1</a>]</span>. But the requirements of borrow
checking and relocation make it most similar to Rust’s feature. Pattern
matching is the only way to access alternatives of choice types. It’s
important in achieving Safe C++’s type safety goals.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/match1.cxx"><strong>match1.cxx</strong></a></p>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>choice Primitive <span class="op">{</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>  i8<span class="op">(</span><span class="dt">int8_t</span><span class="op">)</span>,</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>  i16<span class="op">(</span><span class="dt">int16_t</span><span class="op">)</span>,</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>  i32<span class="op">(</span><span class="dt">int32_t</span><span class="op">)</span>,</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>  i64<span class="op">(</span><span class="dt">int64_t</span><span class="op">)</span>,</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>  i64_2<span class="op">(</span><span class="dt">int64_t</span><span class="op">)</span>,</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>  i64_3<span class="op">(</span><span class="dt">int64_t</span><span class="op">)</span>,</span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>  pair<span class="op">(</span><span class="dt">int</span>, <span class="dt">int</span><span class="op">)</span>,</span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>  s<span class="op">(</span>std2<span class="op">::</span>string<span class="op">)</span></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> test<span class="op">(</span>Primitive obj<span class="op">)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> match<span class="op">(</span>obj<span class="op">)</span> <span class="op">{</span></span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Match 1, 2, 4, or 8 for either i32 or i64.</span></span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>i32<span class="op">(</span><span class="dv">1</span><span class="op">|</span><span class="dv">2</span><span class="op">|</span><span class="dv">4</span><span class="op">|</span><span class="dv">8</span><span class="op">)</span> <span class="op">|</span> <span class="op">.</span>i64<span class="op">(</span><span class="dv">1</span><span class="op">|</span><span class="dv">2</span><span class="op">|</span><span class="dv">4</span><span class="op">|</span><span class="dv">8</span><span class="op">)</span>   <span class="op">=&gt;</span> <span class="dv">1</span>;</span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Match less than 0. ..a is half-open interval.</span></span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>i32<span class="op">(.</span><span class="fl">.0</span><span class="op">)</span>                       <span class="op">=&gt;</span> <span class="dv">2</span>;</span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-23"><a href="#cb71-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Match 100 to 200 inclusive. ..= is closed interval.</span></span>
<span id="cb71-24"><a href="#cb71-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>i32<span class="op">(</span><span class="fl">100.</span><span class="er">.</span><span class="op">=</span><span class="dv">200</span><span class="op">)</span>                 <span class="op">=&gt;</span> <span class="dv">3</span>;</span>
<span id="cb71-25"><a href="#cb71-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-26"><a href="#cb71-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// variant-style access. Match all alternatives with </span></span>
<span id="cb71-27"><a href="#cb71-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// a `int64_t` type. In this case, i64, i64_2 or i64_3</span></span>
<span id="cb71-28"><a href="#cb71-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// matches the pattern.</span></span>
<span id="cb71-29"><a href="#cb71-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="dt">int64_t</span><span class="op">}(</span><span class="dv">500</span> <span class="op">|</span> <span class="fl">1000.</span><span class="er">.2000</span><span class="op">)</span>     <span class="op">=&gt;</span> <span class="dv">4</span>;</span>
<span id="cb71-30"><a href="#cb71-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-31"><a href="#cb71-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Match a 2-tuple/aggregate. Bind declarations x and y to </span></span>
<span id="cb71-32"><a href="#cb71-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the tuple elements. The match-guard passes when x &gt; y.</span></span>
<span id="cb71-33"><a href="#cb71-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>pair<span class="op">([</span>x, y<span class="op">])</span> <span class="cf">if</span> <span class="op">(</span>x <span class="op">&gt;</span> y<span class="op">)</span>        <span class="op">=&gt;</span> <span class="dv">5</span>;</span>
<span id="cb71-34"><a href="#cb71-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-35"><a href="#cb71-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Match everything else.</span></span>
<span id="cb71-36"><a href="#cb71-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Comment the wildcard for an exhaustiveness error.</span></span>
<span id="cb71-37"><a href="#cb71-37" aria-hidden="true" tabindex="-1"></a>    _                               <span class="op">=&gt;</span> <span class="dv">6</span>;</span>
<span id="cb71-38"><a href="#cb71-38" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>;</span>
<span id="cb71-39"><a href="#cb71-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A <em>match-expression</em>’s operand is expression of class, choice,
array, slice, arithmetic, builtin vector or builtin matrix type. The
match body is a set of <em>match-clauses</em>. Each
<em>match-clause</em> has a <em>pattern</em> on the left, an optional
<em>match-guard</em> in the middle, and a <em>match-body</em> after the
<code class="sourceCode cpp"><span class="op">=&gt;</span></code>
token.</p>
<p>A match is rich in the kind of patterns it supports:</p>
<ul>
<li><strong>structured pattern</strong> <code class="sourceCode cpp"><span class="op">[</span>p1, p2<span class="op">]</span></code>
- Matches aggregates and C++ types implementing the
<code class="sourceCode cpp">tuple_size</code>/<code class="sourceCode cpp">tuple_element</code>
customization point. These are useful when destructuring Safe C++’s
first-class tuple and array types. Nest the patterns to destructure
multiple levels of subobjects. The pattern corresponding to structured
bindings and aggregate initializers.</li>
<li><strong>designated pattern</strong> <code class="sourceCode cpp"><span class="op">[</span>x<span class="op">:</span> p1, y<span class="op">:</span> p2<span class="op">]</span></code>
- Matches aggregates by member name rather than ordinal. The pattern
corresponding to designated bindings and designated initializers.</li>
<li><strong>choice pattern</strong>
<code class="sourceCode cpp"><span class="op">.</span>alt</code> or
<code class="sourceCode cpp"><span class="op">.</span>alt<span class="op">(</span>p<span class="op">)</span></code>
- Matches a choice alternative. If the choice alternative has a payload
type, the <code class="sourceCode cpp"><span class="op">.</span>alt<span class="op">(</span>p<span class="op">)</span></code>
opens a pattern on the payload.</li>
<li><strong>variant pattern</strong> <code class="sourceCode cpp"><span class="op">{</span>type<span class="op">}</span></code>
or <code class="sourceCode cpp"><span class="op">{</span>type<span class="op">}(</span>p<span class="op">)</span></code>
- Matches all choice alternatives with a payload type of <em>type</em>.
The <code class="sourceCode cpp"><span class="op">{</span>type<span class="op">}(</span>p<span class="op">)</span></code>
form opens a pattern on the payload.</li>
<li><strong>wildcard pattern</strong>
<code class="sourceCode cpp">_</code> Matches any pattern. These
correspond to the
<code class="sourceCode cpp"><span class="cf">default</span></code> case
of a <em>switch-statement</em> and may be required to satisfy a
<em>match-expression</em>’s exhaustiveness requirement.</li>
<li><strong>rest pattern</strong> -
<code class="sourceCode cpp"><span class="op">..</span></code> Matches
any number of elements. Use inside structured patterns to produce
patterns on the beginning or end elements. Also used to supports
patterns on slice operands.</li>
<li><strong>binding declaration</strong> <em>binding-mode</em>
<code class="sourceCode cpp">decl</code> - Bind a declaration to the
pattern’s operand. There are six binding modes: <em>default</em>,
<code class="sourceCode cpp">cpy</code>,
<code class="sourceCode cpp">rel</code>,
<code class="sourceCode cpp"><span class="op">^</span></code> for
mutable borrows, <code class="sourceCode cpp"><span class="op">^</span><span class="kw">const</span></code>
for shared borrows and
<code class="sourceCode cpp"><span class="op">&amp;</span></code> for
lvalue references.</li>
<li><strong>test pattern</strong> - Name a constant literal or constant
expression inside parentheses. These can be formed into range
expressions with an operand on either or both sides of
<code class="sourceCode cpp"><span class="op">..</span></code> or
<code class="sourceCode cpp"><span class="op">..=</span></code>. The
current operand of the match must match the test pattern to go to the
body.</li>
<li><strong>disjunction pattern</strong>
<code class="sourceCode cpp">p1 <span class="op">|</span> p2</code> -
Separate patterns with the disjunction operator
<code class="sourceCode cpp"><span class="op">|</span></code>.</li>
</ul>
<p>This example uses choice, test, variant, binding, disjunction and
wildcard patterns. The wildcard pattern at the end proves
exhaustiveness.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/proposal/match2.cxx"><strong>match2.cxx</strong></a></p>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">feature on safety</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;std2.h&gt;</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std2;</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>choice Primitive <span class="op">{</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>  i8<span class="op">(</span><span class="dt">int8_t</span><span class="op">)</span>,</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>  u8<span class="op">(</span><span class="dt">uint8_t</span><span class="op">)</span>,</span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>  i16<span class="op">(</span><span class="dt">int16_t</span><span class="op">)</span>,</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>  u16<span class="op">(</span><span class="dt">uint16_t</span><span class="op">)</span>,</span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>  i32<span class="op">(</span><span class="dt">int32_t</span><span class="op">)</span>,</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>  u32<span class="op">(</span><span class="dt">uint32_t</span><span class="op">)</span>,</span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>  i64<span class="op">(</span><span class="dt">int64_t</span><span class="op">)</span>,</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>  u64<span class="op">(</span><span class="dt">uint64_t</span><span class="op">)</span>,</span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>  s<span class="op">(</span>string<span class="op">)</span>;</span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> is_signed<span class="op">(</span><span class="kw">const</span> self<span class="op">^)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// concise form. Equivalent to Rust&#39;s matches! macro.</span></span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> match<span class="op">(*</span>self; <span class="op">.</span>i8 <span class="op">|</span> <span class="op">.</span>i16 <span class="op">|</span> <span class="op">.</span>i32 <span class="op">|</span> <span class="op">.</span>i64<span class="op">)</span>;</span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> is_unsigned<span class="op">(</span><span class="kw">const</span> self<span class="op">^)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> match<span class="op">(*</span>self; <span class="op">.</span>u8 <span class="op">|</span> <span class="op">.</span>u16 <span class="op">|</span> <span class="op">.</span>u32 <span class="op">|</span> <span class="op">.</span>u64<span class="op">)</span>;</span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-26"><a href="#cb72-26" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> is_string<span class="op">(</span><span class="kw">const</span> self<span class="op">^)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb72-27"><a href="#cb72-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> match<span class="op">(*</span>self; <span class="op">.</span>s<span class="op">)</span>;</span>
<span id="cb72-28"><a href="#cb72-28" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb72-29"><a href="#cb72-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb72-30"><a href="#cb72-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-31"><a href="#cb72-31" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> safe <span class="op">{</span></span>
<span id="cb72-32"><a href="#cb72-32" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span>Primitive<span class="op">::</span>i16<span class="op">(</span><span class="dv">5</span><span class="bu">i</span><span class="er">16</span><span class="op">).</span>is_signed<span class="op">())</span>;</span>
<span id="cb72-33"><a href="#cb72-33" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span>Primitive<span class="op">::</span>u32<span class="op">(</span><span class="dv">100</span><span class="bu">u</span><span class="er">i32</span><span class="op">).</span>is_unsigned<span class="op">())</span>;</span>
<span id="cb72-34"><a href="#cb72-34" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span>Primitive<span class="op">::</span>s<span class="op">(</span><span class="st">&quot;Hello safety&quot;</span><span class="op">).</span>is_string<span class="op">())</span>;</span>
<span id="cb72-35"><a href="#cb72-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <em>concise-match-expression</em> is a form of pattern matching
that applies a test and optional <em>match-guard</em> on the operand and
returns true or false. This maps directly to Rust’s <span class="citation" data-cites="matches">[<a href="https://doc.rust-lang.org/std/macro.matches.html" role="doc-biblioref">matches</a>]</span> facility, although instead of
being a macro, this is a first-class language feature.</p>
<h2 data-number="2.6" id="interior-mutability"><span class="header-section-number">2.6</span> Interior mutability<a href="#interior-mutability" class="self-link"></a></h2>
<p>Recall the law of exclusivity, the program-wide invariant that
guarantees a resource isn’t mutated while another user has access to it.
How does this square with the use of shared pointers, which enables
shared ownership of a mutable resource? How does it support threaded
programs, where access to shared mutable state is gated by a mutex?</p>
<p>Shared mutable access exists in this safety model, but the way it’s
enabled involves some trickery. Rust has a blessed type,
<code class="sourceCode cpp">UnsafeCell</code>,<span class="citation" data-cites="unsafe-cell">[<a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html" role="doc-biblioref">unsafe-cell</a>]</span> which encapsulates an
object and provides mutable access to it, <em>through a shared
reference</em>.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> get(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">*</span><span class="kw">mut</span> T</span></code></pre></div>
<p>This is an official way of stripping away const. While the function
is safe, it returns a raw pointer, which is unsafe to dereference. Rust
includes a number of library types which wrap
<code class="sourceCode cpp">UnsafeCell</code> and implement their own
deconfliction strategies to prevent violations of exclusivity.</p>
<ul>
<li><code class="sourceCode cpp">std<span class="op">::</span>Cell<span class="op">&lt;</span>T<span class="op">&gt;</span></code><span class="citation" data-cites="cell">[<a href="https://doc.rust-lang.org/std/cell/struct.Cell.html" role="doc-biblioref">cell</a>]</span> provides get and set methods to
read out the current value and store new values into the protected
resource. Since <code class="sourceCode cpp">Cell</code> can’t be used
across threads, there’s no risk of violating exclusivity.</li>
<li><code class="sourceCode cpp">std<span class="op">::</span>RefCell<span class="op">&lt;</span>T<span class="op">&gt;</span></code><span class="citation" data-cites="ref-cell">[<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html" role="doc-biblioref">ref-cell</a>]</span> is a single-threaded
multiple-read, single-write lock. If the caller requests a mutable
reference to the interior object, the implementation checks its counter,
and if the object is not locked, it establishes a mutable lock and
returns a mutable borrow. If the caller requests a shared reference to
the interior object, the implementation checks that there is no live
mutable borrow, and if there isn’t, increments the counter. When users
are done with the borrow, they have to release the lock, which
decrements the reference count. If the user’s request can’t be serviced,
the <code class="sourceCode cpp">RefCell</code> can either gracefully
return with an error code, or it can panic and abort.</li>
<li><code class="sourceCode cpp">std<span class="op">::</span>Mutex<span class="op">&lt;</span>T<span class="op">&gt;</span></code><span class="citation" data-cites="mutex">[<a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html" role="doc-biblioref">mutex</a>]</span> provides mutable borrows to the
interior data across threads. A mutex synchronization object deconflicts
access, so there’s only one live borrow at a time.</li>
<li><code class="sourceCode cpp">std<span class="op">::</span>RwLock<span class="op">&lt;</span>T<span class="op">&gt;</span></code><span class="citation" data-cites="rwlock">[<a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html" role="doc-biblioref">rwlock</a>]</span> is the threaded multiple-read,
single-write lock. The interface is similar to RefCell’s, but it uses a
mutex for deconfliction, so clients can sit on the lock until their
request is serviced.</li>
</ul>
<p>Safe C++ provides <code class="sourceCode cpp">std2<span class="op">::</span>unsafe_cell</code>
in its standard library. It provides the same interior mutability
strategy as Rust:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">+&gt;</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="op">[[</span><span class="at">unsafe</span><span class="op">::</span><span class="at">sync</span><span class="op">(</span><span class="at">false</span><span class="op">)]]</span> unsafe_cell</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>  T t_;</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>  unsafe_cell<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">explicit</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>  unsafe_cell<span class="op">(</span>T t<span class="op">)</span> <span class="kw">noexcept</span> safe</span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span> t_<span class="op">(</span>rel t<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>  T<span class="op">*</span> get<span class="op">(</span>self <span class="kw">const</span><span class="op">^)</span> <span class="kw">noexcept</span> safe <span class="op">{</span></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">const_cast</span><span class="op">&lt;</span>T<span class="op">*&gt;(</span>addr self<span class="op">-&gt;</span>t_<span class="op">)</span>;</span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>Forming a pointer to the mutable inner state through a shared borrow
is <em>safe</em>, but dereferencing that pointer is unsafe. Safe C++
implements
<code class="sourceCode cpp">std2<span class="op">::</span>cell</code>,
<code class="sourceCode cpp">std2<span class="op">::</span>ref_cell</code>,
<code class="sourceCode cpp">std2<span class="op">::</span>mutex</code>
and <code class="sourceCode cpp">std2<span class="op">::</span>shared_mutex</code>,
which provide safe member functions to access interior state through
their deconfliction strategies.</p>
<p>Safe C++ and Rust and equate exclusive access with mutable types and
shared access with const types. This is an economical choice, because
one type qualifier, const, also determines exclusivity. This awkward
cast-away-const model of interior mutability is the logical consequence.
But it’s not the only way. The Ante language<span class="citation" data-cites="ante">[<a href="https://antelang.org/blog/safe_shared_mutability/#shared-interior-mutability" role="doc-biblioref">ante</a>]</span> experiments with separate mutable
(exclusive) and mutable (shared) type qualifiers. It uses
<code class="sourceCode cpp">own mut</code> and
<code class="sourceCode cpp">shared mut</code> as compound type
qualifiers. That’s really attractive, because the “all mutations are
explicit” ideal can remain in effect–you’re never mutating something
through a const reference. This three-state system doesn’t map onto
C++’s existing type system as easily, but that doesn’t mean the
const/mutable borrow treatment, which does integrate elegantly, is the
most expressive.</p>
<p>&lt; RC/CELL example &gt;</p>
<h2 data-number="2.7" id="send-and-sync"><span class="header-section-number">2.7</span> Send and sync<a href="#send-and-sync" class="self-link"></a></h2>
<p>Rust provides thread safety using a novel extension of the type
system.</p>
<p>To this end, Rust (and now subsequently the Safe C++ extensions)
introduce compiler-intrinsic traits known as
<code class="sourceCode cpp">send</code> and
<code class="sourceCode cpp">sync</code>. These are marker traits that
the type system and libraries uses to reason about the thread-safety of
objects.</p>
<p>The semantic meaning of <code class="sourceCode cpp">send</code> is
that an instance of a type is safe to relocate across thread boundaries.
For many types, such as those who uniquely own a resource, being
<code class="sourceCode cpp">send</code> is almost trivial as all that’s
happening is a pointer is being passed to another thread, i.e. it’s safe
for
<code class="sourceCode cpp">std2<span class="op">::</span>string</code>
to be sent to a new thread because all it does is deallocate a simple
char array.</p>
<p><code class="sourceCode cpp">std2<span class="op">::</span>arc</code>
is another example of a type that’s
<code class="sourceCode cpp">send</code> because even though there can
be multiple concurrent instances of the
<code class="sourceCode cpp">arc</code>, it internally uses atomic
referece counting which means it’s safe to run the destructors on other
threads.
<code class="sourceCode cpp">std2<span class="op">::</span>rc</code> is
an example of a type that can never be soundly
<code class="sourceCode cpp">send</code>, because there can be multiple
copies of the same <code class="sourceCode cpp">rc</code> and the
reference counting is not atomic which creates a data race.</p>
<p><code class="sourceCode cpp">sync</code> is a trait that denotes if
an immutable reference to a type is safe to be shared among multiple
threads. In the general case, a type is
<code class="sourceCode cpp">sync</code> if <code class="sourceCode cpp">T <span class="kw">const</span><span class="op">^</span></code>
is <code class="sourceCode cpp">send</code>. Elaborating, this means
that if it’s safe to send a reference across thread boundaries, we can
infer that the type is safe in a multi-threaded context. Again,
<code class="sourceCode cpp">std2<span class="op">::</span>arc</code> is
<code class="sourceCode cpp">sync</code> because it’s safe to send <code class="sourceCode cpp">std2<span class="op">::</span>arc <span class="kw">const</span><span class="op">^</span></code>
across threads. A calling thread can freely copy the
<code class="sourceCode cpp">arc</code> via its immutable reference
without introducing a data race. Conversely, <code class="sourceCode cpp">std2<span class="op">::</span>rc <span class="kw">const</span><span class="op">^</span></code>
cannot be <code class="sourceCode cpp">send</code> because if a calling
thread copies the <code class="sourceCode cpp">rc</code>, then it
non-atomically modifies the reference count which is a data race.</p>
<p>It is worth noting that on a pedantic level, many of these types are
conditionally <code class="sourceCode cpp">send</code> and
<code class="sourceCode cpp">sync</code> based on the underlying
<code class="sourceCode cpp">T</code> they’re templated on. Consider the
declaration of
<code class="sourceCode cpp">std2<span class="op">::</span>arc</code>:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">+&gt;</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="op">[[</span><span class="at">unsafe</span><span class="op">::</span><span class="at">send</span><span class="op">(</span><span class="at">T</span><span class="op">~</span><span class="at">is_send </span><span class="op">&amp;&amp;</span><span class="at"> T</span><span class="op">~</span><span class="at">is_sync</span><span class="op">)</span>,<span class="at"> unsafe</span><span class="op">::</span><span class="at">sync</span><span class="op">(</span><span class="at">T</span><span class="op">~</span><span class="at">is_send </span><span class="op">&amp;&amp;</span><span class="at"> T</span><span class="op">~</span><span class="at">is_sync</span><span class="op">)]]</span> arc;</span></code></pre></div>
<p>We see here that <code class="sourceCode cpp">arc</code> is only
<code class="sourceCode cpp">send</code> and
<code class="sourceCode cpp">sync</code> if the underlying
<code class="sourceCode cpp">T</code> is both
<code class="sourceCode cpp">sync</code> <em>and</em>
<code class="sourceCode cpp">sync</code>. This is because to be fully
sound, the type must be able to have its destructor run on any thread
(hence <code class="sourceCode cpp">send</code>) and because
<code class="sourceCode cpp">arc</code>s support dereferencing, <code class="sourceCode cpp">T <span class="kw">const</span><span class="op">^</span></code>
is available to any and all threads.</p>
<p>Authors of types are free to manually implement these traits as they
see fit, so long as the author of the type understands they honor this
at the penalty of breaking memory safety.</p>
<p>By default, types with interior mutability are inherently not
<code class="sourceCode cpp">send</code>/<code class="sourceCode cpp">sync</code>.
The root of all interior mutability is <code class="sourceCode cpp">std2<span class="op">::</span>unsafe_cell<span class="op">&lt;</span>T<span class="op">&gt;</span></code>
which is uncoditionally <code class="sourceCode cpp"><span class="op">[[</span><span class="at">unsafe</span><span class="op">::</span><span class="at">sync</span><span class="op">(</span><span class="at">false</span><span class="op">)]]</span></code>.
If <code class="sourceCode cpp">T</code> is not
<code class="sourceCode cpp">sync</code> then by definition we know that
<code class="sourceCode cpp">T <span class="kw">const</span><span class="op">^</span></code>
is not <code class="sourceCode cpp">send</code> because it cannot be
sent safely across thread boundaries so we only need to specify one
market trait in its definition.</p>
<p>Types that wrap <code class="sourceCode cpp">unsafe_cell</code> are
able to manually implement the marker traits, provided the author
ensures soundness. This is how
<code class="sourceCode cpp">std2<span class="op">::</span>mutex</code>
is implemented:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">+&gt;</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="op">[[</span><span class="at">unsafe</span><span class="op">::</span><span class="at">send</span><span class="op">(</span><span class="at">T</span><span class="op">~</span><span class="at">is_send</span><span class="op">)</span>,<span class="at"> unsafe</span><span class="op">::</span><span class="at">sync</span><span class="op">(</span><span class="at">T</span><span class="op">~</span><span class="at">is_send</span><span class="op">)]]</span> mutex;</span></code></pre></div>
<p>Note for <code class="sourceCode cpp">mutex</code> that the
<code class="sourceCode cpp">send</code> and
<code class="sourceCode cpp">sync</code> bounds are defined based on the
<code class="sourceCode cpp">send</code>-ability of the type. This is
because the <code class="sourceCode cpp">mutex</code> is responsible for
implementing the <code class="sourceCode cpp">sync</code> aspect but
because the <code class="sourceCode cpp">mutex</code> enables mutable
access to the underlying data, the wrapped object can be relocated out
of and the destructor of the type can be run on a new thread.</p>
<p>Creating the correct <code class="sourceCode cpp">send</code> and
<code class="sourceCode cpp">sync</code> bounds is often a non-trivial
task but we have prior art to base our code off of.</p>
<p>One of the more compelling usages of interior mutability is making
data accesses thread-safe. In C++, many production codebases will couple
an
<code class="sourceCode cpp">std<span class="op">::</span>mutex</code>
alongside the data it’s guarding in a wrapper struct. This provides a
strong and safe guarantee but is not offered by default and its use is
not guaranteed.</p>
<p>In Safe C++, the stdlib offers a safe abstraction for users and
eschewing it requires an explicit opt-in via
<code class="sourceCode cpp">unsafe</code> constructs.
<code class="sourceCode cpp">std2<span class="op">::</span>mutex</code>
internally uses an <code class="sourceCode cpp">std2<span class="op">::</span>unsafe_cell</code>.</p>
<p>The idiomatic usage of
<code class="sourceCode cpp">std2<span class="op">::</span>mutex</code>
is via
<code class="sourceCode cpp">std2<span class="op">::</span>arc</code> as
<code class="sourceCode cpp"><span class="kw">static</span></code>
objects with non-trivial destructors are unsafe.
<code class="sourceCode cpp">std2<span class="op">::</span>arc</code> is
safe to copy across thread boundaries which means that at any given
point in time, we must assume that multiple threads are attempting to
access the data at the same time. Because of this, there’s no infallible
API that permits access via a direct mutable reference to the data the
<code class="sourceCode cpp">arc</code> is wrapping.</p>
<p>However, it’s always safe to treat a const reference as thread-safe.
This means the user must access the inner mutex of <code class="sourceCode cpp">arc<span class="op">&lt;</span>mutex<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></code>
via const references. To this end, we can leverage interior mutability
to guarantee a lock is acquired before handing out a mutable reference.
Consider the following code:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> add<span class="op">(</span>std2<span class="op">::</span>arc<span class="op">&lt;</span>std2<span class="op">::</span>mutex<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> mtx, <span class="dt">int</span> x, <span class="dt">int</span> y<span class="op">)</span> safe</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> z <span class="op">=</span> x <span class="op">+</span> y;</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span><span class="op">^</span> r; <span class="co">// unbound mutable reference</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// acquire a RAII handle that&#39;s constrained on mtx&#39;s lifetime</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// note that `mtx` access is const here, as there&#39;s no mutable context</span></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// here we invoke: `T const^ arc::operator-&gt;(self const^) noexcept safe;`</span></span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// which in turn lets us invoke: `lock_guard lock(self const^) safe;` on the</span></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// mutex object</span></span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> guard <span class="op">=</span> mtx<span class="op">-&gt;</span>lock<span class="op">()</span>;</span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// locally, use a mutable borrow of the `guard` object to invoke the</span></span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// similarly named `borrow(self^)` member function, which acquires</span></span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// exclusive access of the mutex via a `.lock()` call on a `std::mutex`.</span></span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the local exclusive borrow of the `guard` object prevents potential</span></span>
<span id="cb76-17"><a href="#cb76-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// misuse like double-locking and other lifetime-related issues</span></span>
<span id="cb76-18"><a href="#cb76-18" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> mut guard<span class="op">.</span>borrow<span class="op">()</span>;</span>
<span id="cb76-19"><a href="#cb76-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-20"><a href="#cb76-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// now assign the result of the operation through the mutable reference</span></span>
<span id="cb76-21"><a href="#cb76-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>r <span class="op">=</span> z;</span>
<span id="cb76-22"><a href="#cb76-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb76-23"><a href="#cb76-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb76-24"><a href="#cb76-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-25"><a href="#cb76-25" aria-hidden="true" tabindex="-1"></a><span class="co">// spawn the thread, copying the `mtx` object</span></span>
<span id="cb76-26"><a href="#cb76-26" aria-hidden="true" tabindex="-1"></a>std2<span class="op">::</span>arc<span class="op">&lt;</span>std2<span class="op">::</span>mutex<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> mtx<span class="op">{</span>std2<span class="op">::</span>mutex<span class="op">(</span><span class="dv">1234</span><span class="op">)}</span>;</span>
<span id="cb76-27"><a href="#cb76-27" aria-hidden="true" tabindex="-1"></a>std2<span class="op">::</span>thread t<span class="op">(</span>add, cpy mtx, <span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span>;</span>
<span id="cb76-28"><a href="#cb76-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-29"><a href="#cb76-29" aria-hidden="true" tabindex="-1"></a><span class="co">// perform a safe-guarded load, similar to what&#39;s done above</span></span>
<span id="cb76-30"><a href="#cb76-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> r <span class="op">=</span> <span class="op">*</span>mtx<span class="op">-&gt;</span>lock<span class="op">()</span>;</span>
<span id="cb76-31"><a href="#cb76-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-32"><a href="#cb76-32" aria-hidden="true" tabindex="-1"></a><span class="co">// this condition never fails</span></span>
<span id="cb76-33"><a href="#cb76-33" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>r <span class="op">!=</span> <span class="dv">1234</span><span class="op">)</span> assert_eq<span class="op">(</span>r, <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span><span class="op">)</span>;</span>
<span id="cb76-34"><a href="#cb76-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-35"><a href="#cb76-35" aria-hidden="true" tabindex="-1"></a><span class="co">// joining the thread object consumes it, making it unusable in further</span></span>
<span id="cb76-36"><a href="#cb76-36" aria-hidden="true" tabindex="-1"></a><span class="co">// operations</span></span>
<span id="cb76-37"><a href="#cb76-37" aria-hidden="true" tabindex="-1"></a>t rel<span class="op">.</span>join<span class="op">()</span>;</span></code></pre></div>
<p>Making sound thread-safe code necessitates interior mutability, which
requires a compiler primitive to make the
<code class="sourceCode cpp"><span class="kw">const_cast</span></code>
valid. The library is manually upholding invariants around exlusivity
via unsafe constructs but what results is a sound interface that is
impossible to misuse.</p>
<h1 data-number="3" id="unresolved-or-unimplemented-design-issues"><span class="header-section-number">3</span> Unresolved or unimplemented
design issues<a href="#unresolved-or-unimplemented-design-issues" class="self-link"></a></h1>
<h2 data-number="3.1" id="expression-outlives-constraint"><span class="header-section-number">3.1</span>
<em>expression-outlives-constraint</em><a href="#expression-outlives-constraint" class="self-link"></a></h2>
<p>C++ variadics don’t convey lifetime constraints from the function’s
return type to its parameters. Calls like
<code class="sourceCode cpp">make_unique</code> and
<code class="sourceCode cpp">emplace_back</code> take parameters
<code class="sourceCode cpp">Ts<span class="op">...</span> args</code>
and return an unrelated type <code class="sourceCode cpp">T</code>. This
may trigger the borrow checker, because the implementation of the
function will produce free regions with unrelated endpoints. It’s not a
soundness issue, but it is a serious usability issue.</p>
<p>We need an <em>expression-outlives-constraint</em>, a programmatic
version of <em>outlives-constrant</em> <code class="sourceCode cpp"><span class="op">/(</span>where a <span class="op">:</span> b<span class="op">)</span></code>.
It consists of an <em>expression</em> in an unevaluated context, which
names the actual function parameters and harvests the lifetime
constraints implied by those expressions. We should name function
parameters rather than declvals of their types, because they may be
borrows with additional constraints than their template lifetime
parameters have.</p>
<p>In order to name the function parameters, we’ll need a trailing
<em>expression-lifetime-constraint</em> syntax. Something like,</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">+</span>, <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">+&gt;</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>box<span class="op">&lt;</span>T<span class="op">&gt;</span> make_box<span class="op">(</span>Ts<span class="op">...</span> args<span class="op">)</span> safe where<span class="op">(</span>T<span class="op">:</span>T<span class="op">(</span>rel args<span class="op">...))</span>;</span></code></pre></div>
<p>There’s a unique tooling aspect to this. To evaluate the implied
constraints of the outlives expression, we have lower the expression to
MIR, create new region variables for the locals, generate constraints,
solve the constraint equation, and propagate region end points up to the
function’s lifetime parameters.</p>
<h2 data-number="3.2" id="function-parameter-ownership"><span class="header-section-number">3.2</span> Function parameter ownership<a href="#function-parameter-ownership" class="self-link"></a></h2>
<p>The C++ Standard does not specify parameter passing conventions.
That’s left to implementers. Unfortunately, different implementers
settled on different conventions.</p>
<blockquote>
<p>If the type has a non-trivial destructor, the caller calls that
destructor after control returns to it (including when the caller throws
an exception).</p>
<p>– <cite>Itanium C++ ABI: Non-Trivial Parameters</cite><span class="citation" data-cites="itanium-abi">[<a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#non-trivial-parameters" role="doc-biblioref">itanium-abi</a>]</span></p>
</blockquote>
<p>In the Itanium C++ ABI, callers destruct function arguments after the
callee has returned. This isn’t compatible with Safe C++’s relocation
object model. If you relocate from a function parameter into a local
object, then the object would be destructed <em>twice</em>: once by the
callee when the local object goes out of scope and once by the caller on
the function parameter’s address when the callee returns. Safe C++
specifies this aspect of parameter passing: the callee is responsible
for destroying its own function parameters. If a function parameter is
relocated out of, that parameter becomes uninitialized and drop
elaboration elides its destructor call.</p>
<p>Let’s say all functions declared in the <code class="sourceCode cpp"><span class="op">[</span>safety<span class="op">]</span></code>
feature implement the <em>relocate calling convention</em>. Direct calls
to them should be no problem. This includes virtual calls. Direct calls
to the legacy ABI from the relocate ABI should be no problem. And calls
going the other way–where the caller is in the legacy ABI and the callee
implements the relocate ABI is not an issue either.</p>
<p>The friction comes when forming function pointers or
pointers-to-member functions for indirect calls. The pointer has to
contain ABI information in its type, and a pointer to a relocate ABI
function must have a different type than a pointer to the equivalent
legacy ABI function. Ideally we’d have an undecorated function pointer
type that can point to either legacy or relocate ABI functions, creating
a unified type for indirect function calls.</p>
<p>Consider these three new ABIs:</p>
<ul>
<li><code class="sourceCode cpp">__relocate</code> - Relocate CC. Callee
destroys parameters. This is opt-in for both legacy and <code class="sourceCode cpp"><span class="op">[</span>safety<span class="op">]</span></code>
modes.</li>
<li><code class="sourceCode cpp">__legacy</code> - Legacy CC. The
system’s default calling convention. For Itanium ABI, the caller
destroys arguments.</li>
<li><code class="sourceCode cpp">__unified</code> - A unified CC that
holds function pointers of either the above types. The implementer can
use the most significant bit to store a discriminator between CCs:
set=<code class="sourceCode cpp">__relocate</code>,
cleared=<code class="sourceCode cpp">__legacy</code>. This is the
default for the <code class="sourceCode cpp"><span class="op">[</span>safety<span class="op">]</span></code>
mode.</li>
</ul>
<p>There’s a standard conversion from both
<code class="sourceCode cpp">__legacy</code> and
<code class="sourceCode cpp">__relocate</code> function pointers to the
<code class="sourceCode cpp">__unified</code> function pointer type. The
latter is a trivial bit-cast. The former merely demands setting the most
significant bit.</p>
<p>Surprisingly, we can also support standard conversions from a
<code class="sourceCode cpp">__unified</code> function pointer to the
<code class="sourceCode cpp">__legacy</code> and
<code class="sourceCode cpp">__relocate</code> function poiner types. If
it’s a mismatch, the null pointer is returned. This is still memory
safe, because dereferencing a pointer is the unsafe operation. However,
standard conversions from <code class="sourceCode cpp">__unified</code>
function references to <code class="sourceCode cpp">__legacy</code> and
<code class="sourceCode cpp">__relocate</code> references are not
supported, because references may not hold nullptr.</p>
<h2 data-number="3.3" id="non-static-member-functions-with-lifetimes"><span class="header-section-number">3.3</span> Non-static member functions
with lifetimes<a href="#non-static-member-functions-with-lifetimes" class="self-link"></a></h2>
<p>At this point in development, lifetime parameters are not supported
for non-static member functions where the enclosing class has lifetime
parameters, including including template lifetime parameters. Use the
<code class="sourceCode cpp">self</code> parameter to declare an
explicit object parameter. Non-static member functions don’t have full
object parameter types, which makes it confusing to know where to attach
lifetime arguments. As the project matures it’s likely that this
capability will be included.</p>
<p>Constructors, destructors and the relocation constructor don’t take
explicit <code class="sourceCode cpp">self</code> parameters. But that’s
less problematic because the language won’t form function pointers to
these or allow pointer-to-member function calls.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Foo<span class="op">/</span>a <span class="op">{</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Self parameter syntax. Supported.</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> func1<span class="op">(</span>Foo<span class="op">^/</span>a self, <span class="dt">int</span> x<span class="op">)</span> safe;</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Equivalent abbreviated self parameter syntax. Supported.</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> func2<span class="op">(</span>self<span class="op">^</span>, <span class="dt">int</span> x<span class="op">)</span> safe;</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Possible non-static member function syntax.</span></span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Bind a mutable borrow.</span></span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> func3<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">^</span> safe;</span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Bind a shared borrow.</span></span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> func4<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="kw">const</span><span class="op">^</span> safe;</span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-15"><a href="#cb78-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Bind a consuming object. cv-qualifiers are unsupported.</span></span>
<span id="cb78-16"><a href="#cb78-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> func5<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> rel safe;</span>
<span id="cb78-17"><a href="#cb78-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p>Supporting
<code class="sourceCode cpp"><span class="op">^</span></code> and
<code class="sourceCode cpp">rel</code> in the <em>ref-qualifier</em> on
a function declarator is a prospective syntax for supporting borrows and
relocation on the implicit object. However, inside the functions, you’d
still need to use the <code class="sourceCode cpp">self</code> keyword
rather than
<code class="sourceCode cpp"><span class="kw">this</span></code>,
because <code class="sourceCode cpp"><span class="kw">this</span></code>
produces pointers and it’s unsafe dereferencing pointers.</p>
<h2 data-number="3.4" id="relocation-out-of-references"><span class="header-section-number">3.4</span> Relocation out of references<a href="#relocation-out-of-references" class="self-link"></a></h2>
<p>You can only relocate out of <em>owned places</em>, and owned places
are subobjects of local variables. Dereferences of borrows are not owned
places, so you can’t relocate out of them. Niko Matsakis writes about a
significant potential improvement in the ownership model, <span class="citation" data-cites="unwinding-puts-limits-on-the-borrow-checker">[<a href="https://smallcultfollowing.com/babysteps/blog/2024/05/02/unwind-considered-harmful/#unwinding-puts-limits-on-the-borrow-checker" role="doc-biblioref">unwinding-puts-limits-on-the-borrow-checker</a>]</span>
citing situations where it would be sound to relocate out of a
reference, as long as you relocate back into it before the function
returns.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> swap<span class="op">&lt;</span>T<span class="op">&gt;</span>(</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    a<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> T<span class="op">,</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    b<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> T<span class="op">,</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>) <span class="op">{</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> tmp <span class="op">=</span> <span class="op">*</span>a<span class="op">;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>a <span class="op">=</span> <span class="op">*</span>b<span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>b <span class="op">=</span> tmp<span class="op">;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The blog post considers the above swap function, which transliterates
to the Safe C++ code below.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>T<span class="op">^</span> a, T<span class="op">^</span> b<span class="op">)</span> safe <span class="op">{</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>  T tmp <span class="op">=</span> rel <span class="op">*</span>a;</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>a <span class="op">=</span> rel <span class="op">*</span>b;</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>b <span class="op">=</span> rel tmp;</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This code doesn’t compile under Rust or Safe C++ because the operand
of the relocation is a projection involving a reference, which is not an
<em>owned place</em>. This defeats the abilities of initialization
analysis.</p>
<p>In Rust, every function call is potentially throwing, including
destructors. In some builds, panics are throwing, allowing array
subscripts to exit a function on the cleanup path. In debug builds,
integer arithmetic may panic to protect against overflow. There are many
non-return paths out functions, and unlike C++, Rust lacks a
<em>noexcept-specifier</em> to disable cleanup. Matsakis suggests that
relocating out of references is not implemented because its use would be
limited by the many unwind paths out of a function, making it rather
uneconomical to support.</p>
<p>It’s already possible to write C++ code that is less burdened by
cleanup paths than Rust. If Safe C++ adopted the <code class="sourceCode cpp"><span class="cf">throw</span><span class="op">()</span></code>
specifier from the Static Exception Specification,<span class="citation" data-cites="P3166R0">[<a href="https://wg21.link/p3166r0" role="doc-biblioref">P3166R0</a>]</span> we could statically verify that
functions don’t have internal cleanup paths. It may be worthwhile to
give
<code class="sourceCode cpp"><span class="kw">noexcept</span></code>
interfaces to <code class="sourceCode cpp">vector</code> and similar
containers. Exceptions are a poor way to signal out-of-memory states. If
containers panicked on out-of-memory, we’d enormously reduce the cleanup
paths in most functions. Reducing cleanup paths extends the supported
interval between relocating out of a reference and restoring an object
there, helping justify the cost of more complex initialization
analysis.</p>
<p>This extended relocation feature is some of the ripest low-hanging
fruit for improving the safety experience in Safe C++.</p>
<h2 data-number="3.5" id="a-change-of-defaults"><span class="header-section-number">3.5</span> A change of defaults<a href="#a-change-of-defaults" class="self-link"></a></h2>
<h1 data-number="4" id="implementation-guidance"><span class="header-section-number">4</span> Implementation guidance<a href="#implementation-guidance" class="self-link"></a></h1>
<p>The intelligence behind the <em>ownership and borrowing</em> safety
model resides in the compiler’s middle-end, in its <em>MIR analysis</em>
passes. The first thing compiler engineers should focus on when pursuing
Safe C++ is to lower their frontend’s AST to MIR. Several compiled
languages already pass through a mid-level IR: Swift passes through
SIL,<span class="citation" data-cites="sil">[<a href="https://github.com/swiftlang/swift/blob/main/docs/SIL.rst" role="doc-biblioref">sil</a>]</span> Rust passes through MIR,<span class="citation" data-cites="mir">[<a href="https://rustc-dev-guide.rust-lang.org/mir/index.html" role="doc-biblioref">mir</a>]</span> and Circle passes through it’s
mid-level IR when targeting the relocation object model. There is an
effort called ClangIR<span class="citation" data-cites="clangir">[<a href="https://discourse.llvm.org/t/rfc-upstreaming-clangir/76587" role="doc-biblioref">clangir</a>]</span> to lower Clang to an MLIR
dialect called CIR, but the project is in an early phase and doesn’t
have enough coverage to support the language or library features
described in this document.</p>
<p>The AST-&gt;MIR and MIR-&gt;LLVM (or whatever codegen is used) fully
replaces the compiler’s old codegen. It’s modestly more difficult to
write the MIR path, due to greater hygiene required: subobjects and
dereferences must be hierarchicallymust be</p>
<p>Once there is a MIR representation with adequete coverage, begin work
on the MIR analysis. Borrow checking is a very intricate algorithm, but
fortunately it’s easy to print the MIR and the lifetime and outlives
constraints as you lower and check functions, so developers know where
they’re at. The NLL RFC<span class="citation" data-cites="borrow-checking">[<a href="https://rust-lang.github.io/rfcs/2094-nll.html" role="doc-biblioref">borrow-checking</a>]</span> is sufficient to get
developers started on MIR analysis. By my count there are seven rounds
of operations on the MIR in the compiler’s middle-end:</p>
<ol type="1">
<li><strong>Initialization analysis</strong> - Perform forward dataflow
analysis on the control flow graph, finding all program points where a
place is initialized or uninitialized. This can be computed efficiently
with gen-kill analysis,<span class="citation" data-cites="gen-kill">[<a href="https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems" role="doc-biblioref">gen-kill</a>]</span> in which the gen and kill
states within a basic block or computed once and memoized into a pair of
bit vectors. An iterative fixed-point solver follows the control flow
graph and applies the gen-kill vectors to each basic block. After
establishing the initialization for each place, raise errors if any
uninitialized, partially initialized or potentially initialized place is
used.</li>
<li><strong>Live analysis</strong> - Invent new region variables for
each lifetime binder on each local variable in the function. Perform
reverse dataflow analysis on the control flow graph to find all program
points where a region is live or dead. A region is live when the borrow
it is bound to may be dereferenced at a subsequent point in the
program.</li>
<li><strong>Variance analysis</strong> - Inter-procedural live analysis
solves the <em>constraint equation</em>. The constraints go one way:
<code class="sourceCode cpp"><span class="ch">&#39;R</span><span class="er">1 : </span><span class="ch">&#39;</span>R2 <span class="op">@</span> P3</code>
reads “R1 outlives R2 starting from the point P3.” Variance<span class="citation" data-cites="variance">[<a href="https://rust-lang.github.io/rfcs/0738-variance.html" role="doc-biblioref">variance</a>]</span> relates the lifetime
parameterizations of function parameters and return types to these
one-way constraints. It’s necessary to examine the definitions of
classes with lifetime binders, and to recursively examine their data
member types, in order to solve for the variance<span class="citation" data-cites="taming-the-wildcards">[<a href="https://yanniss.github.io/variance-pldi11.pdf" role="doc-biblioref">taming-the-wildcards</a>]</span> for each function
call. Failure to appropriately solve for variance can result in
soundness holes, as illustrated by cve-rs<span class="citation" data-cites="cve-rs">[<a href="https://github.com/Speykious/cve-rs" role="doc-biblioref">cve-rs</a>]</span>, which drew attention to this
advanced aspect of the safety model.</li>
<li><strong>Type relation</strong> - Emit lifetime constraints to relate
assignments from one object with a region variable to another object
with a region variable. The variance of lifetime parameters determines
the directionality of lifetime constraints.</li>
<li><strong>Solve the constraint equation</strong> - Iteratively grow
region variables until all lifetime constraints emitted during type
relation are satisfied. We now have <em>inter-procedural live
analysis</em>: we know the full set of live borrows, <em>even through
function calls</em>.</li>
<li><strong>Borrow checking</strong> - Visit all instructions in the
control flow graph. For all <em>loans in scope</em> (i.e. the set of
loans live at each program point) test for invalidating actions.<span class="citation" data-cites="how-the-borrow-check-works">[<a href="https://rust-lang.github.io/rfcs/2094-nll.html#layer-5-how-the-borrow-check-works" role="doc-biblioref">how-the-borrow-check-works</a>]</span> If there’s a
read or write on an object with a mutable borrow in scope, or a write to
an object with a shared borrow in scope, that violates exclusivity, and
a borrowck errors is raised. The borrow checker also detects invalid end
points in free region variables.</li>
<li><strong>Drop elaboration</strong> - The relocation object model may
leave objects uninitialized, partially initialized or potentially
initialized at the point where they go out of scope. Drop elaboration
erases drops on uninitialized places, replaces drops on partially
initialized places with drops only on the initialized subobjects, and
gates drops on potentially initialized places behind drop flags. Drop
elaboration changes your program, and is the reason why MIR isn’t just
an analysis representation, but a transformation between the AST and the
code generator.</li>
</ol>
<p>The most demanding frontend work work involves piping information
from the frontend down to the MIR. Lifetime parameters on functions and
classes and lifetime arguments on lifetime binders necessitate a
comprehensive change to the compiler’s type system. Wherever there’s a
type, you may now have a <em>lifetime-qualified type</em>. (That is, a
type with bound lifetimes.)</p>
<p>Template specialization involves additional deduplication work, where
lifetime arguments on template argument types are replaced by proxy
lifetime arguments. This helps canonicalize specializations while
preserving the relationship established by its lifetime
parameterization. Lifetime normalization and canonicalization is also
very challenging to implement, partly because there is no precedent for
lifetime language entities in C++. This aspect of the frontend work is
by far the most difficult programming that will be faced when
implementing memory safety for C++. The dataflow analysis by contrast is
very easy, mostly because the MIR is such an elegant language for
expressing programs at that phase.</p>
<p>Implementing the <em>safe-specifier</em> and <em>safe-operator</em>
is easily achieved by duplicating the <em>noexcept</em> code paths.
These features are implemented in the frontend with similar means, and
their noexceptness/safeness are both conveyed through flags on
expressions.</p>
<p>Supporting the <code class="sourceCode cpp">unsafe</code> type
qualifier is more challenging, because the
<code class="sourceCode cpp"><span class="kw">const</span></code> and
<code class="sourceCode cpp"><span class="kw">volatile</span></code>
qualifiers offer less guidance. Unlike the cv-qualifiers, the unsafe
qualifier is ignored when examining pairs of types for ref-relation, but
is attached to prvalues that are the result of lvalue-to-rvalue
conversions, pointer adjustments, subobject access and the like.</p>
<p>There are some new syntax requirements. Circle chose the <code class="sourceCode cpp"><span class="pp">#</span><span class="er">feature</span></code>
directive to accommodate deep changes to the grammar and semantics of
the language with a per-file scope, rather than per-translation unit
scope. The directive is implemented by notionally including a mask of
active features for each token in the translation unit. During
tokenization, identifier tokens check their feature masks for the
[safety] feature, which enables the promotion of the
<code class="sourceCode cpp">safe</code>,
<code class="sourceCode cpp">unsafe</code>,
<code class="sourceCode cpp">cpy</code>,
<code class="sourceCode cpp">rel</code>,
<code class="sourceCode cpp">match</code>,
<code class="sourceCode cpp">mut</code> and etc tokens as keywords. For
the most part the frontend can simply match against these new keywords
when parsing the input and building the AST. Certain aspects of the
relocation object model, such as drop-and-replace instead of invoking
assignment operators, don’t involve new keywords and are implemented by
testing the object model mode of the current function (which indicates
the state of the [safety] flag at the start of the function’s
definition).</p>
<p>In addition to the core safety features, there are many new types
that put a demand on engineering resources: borrows, choice types (and
pattern matching to use them), first-class tuples, arrays and slices.
Interfaces and interface templates are a new language mechanism that
provides customization points to C++, making it much easier to author
libraries that are called directly by the language. Examples in Safe C++
are the iterator support for ranged-for statements, send/sync for thread
safety and fmt interfaces for f-strings.</p>
<h1 data-number="5" id="conclusion"><span class="header-section-number">5</span> Conclusion<a href="#conclusion" class="self-link"></a></h1>
<p>The US Government is telling industry to stop using C++ for reasons
of national security. Academia is turning away in favor of languages
like Rust and Swift that are built on modern technology. Tech executives
are pushing their organizations to move to Rust.<span class="citation" data-cites="russinovich">[<a href="https://x.com/markrussinovich/status/1571995117233504257?lang=en" role="doc-biblioref">russinovich</a>]</span> All this dilutes the
language’s value to novices. That’s trouble for companies which rely on
a pipeline of new C++ developers to continue their operations.</p>
<p>Instead of being received as a threat, we take the safety model
developed by Rust as an opportunity to strengthen C++. The Rust
community has spent a decade generating <em>soundness knowledge</em>,
which is the tactics and strategies (interior mutability, send/sync,
borrow checking, and so on) for achieving memory safety without the
overhead of garbage collection. Their investment in soundness knowledge
informs our design of Safe C++. Adopting the same <em>ownership and
borrowing</em> safety model that security professionals have been
pointing to is the sensible and timely way to keep C++ viable for
another generation.</p>
<p>Safe C++ must provide safe alternatives to everything in today’s
Standard Library. Adoption will look daunting to teams that maintain
large applications. However, users aren’t compelled to switch everything
over at once. If you need to stick with some legacy types, that’s fine.
The compiler can’t enforce sound usage of that code, but that’s always
been the case. As developers incorporate more of the safe standard
library, their safety coverage increases. This is not an all-or-nothing
system. Some unsafe code doesn’t mean that your whole project is unsafe.
A project with 50% safe code should have half as many undetected
soundness bugs as a project with no safe code. A project with 99% safe
code, as many Rust applications have, should have 1% as many undetected
soundness bugs. Rather than focusing on the long tail of difficult use
cases, we encourage developers to think about the bulk of code that is
amenable to the safety improvements that a mature Safe C++ toolchain
will offer.</p>
<p>We’re co-designing the Safe C++ standard library along with the
language extensions. Visit our repository to follow our work, or visit
our Slack channel to get involved:</p>
<blockquote>
<p>https://github.com/cppalliance/safe-cpp
https://cpplang.slack.com/archives/C07GH9NFK0F</p>
</blockquote>
<p>Everything in this proposal took about 18 months to design and
implement in Circle. With participation from industry, we could resolve
the remaining design questions and in another 18 months have a language
and standard library robust enough for mainstream evaluation. While Safe
C++ is a large extension to the language, the cost of building new
tooling is not steep. If C++ continues to go forward without a memory
safety strategy, that’s because institutional users are choosing not to
pursue it; it’s not because memory-safe tooling is too expensive or
difficult to build.</p>
<p>An earlier version of this work was presented to SG23 at the St Louis
2024 ISO meeting, with the closing poll “We should promise more
committee time on borrow checking?” — SF: 20, WF: 7, N: 1, WA: 0, SA:
0.</p>
<h1 data-number="6" id="bibliography"><span class="header-section-number">6</span> References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="1" role="doc-bibliography">
<div id="ref-ante" class="csl-entry" role="doc-biblioentry">
[ante] Ante Shared Interior Mutability. <a href="https://antelang.org/blog/safe_shared_mutability/#shared-interior-mutability"><div class="csl-block">https://antelang.org/blog/safe_shared_mutability/#shared-interior-mutability</div></a>
</div>
<div id="ref-arc" class="csl-entry" role="doc-biblioentry">
[arc] Automatic reference counting. <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/"><div class="csl-block">https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/</div></a>
</div>
<div id="ref-borrow-checking" class="csl-entry" role="doc-biblioentry">
[borrow-checking] The Rust RFC Book - Non-lexical lifetimes. <a href="https://rust-lang.github.io/rfcs/2094-nll.html"><div class="csl-block">https://rust-lang.github.io/rfcs/2094-nll.html</div></a>
</div>
<div id="ref-cell" class="csl-entry" role="doc-biblioentry">
[cell] Cell. <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><div class="csl-block">https://doc.rust-lang.org/std/cell/struct.Cell.html</div></a>
</div>
<div id="ref-cisa-roadmaps" class="csl-entry" role="doc-biblioentry">
[cisa-roadmaps] CISA Releases Joint Guide for Software Manufacturers :
The Case for Memory Safe Roadmaps. <a href="https://www.cisa.gov/news-events/alerts/2023/12/06/cisa-releases-joint-guide-software-manufacturers-case-memory-safe-roadmaps"><div class="csl-block">https://www.cisa.gov/news-events/alerts/2023/12/06/cisa-releases-joint-guide-software-manufacturers-case-memory-safe-roadmaps</div></a>
</div>
<div id="ref-cisa-urgent" class="csl-entry" role="doc-biblioentry">
[cisa-urgent] The Urgent Need for Memory Safety in Software Products. <a href="https://www.cisa.gov/news-events/news/urgent-need-memory-safety-software-products"><div class="csl-block">https://www.cisa.gov/news-events/news/urgent-need-memory-safety-software-products</div></a>
</div>
<div id="ref-clangir" class="csl-entry" role="doc-biblioentry">
[clangir] Upstreaming ClangIR. <a href="https://discourse.llvm.org/t/rfc-upstreaming-clangir/76587"><div class="csl-block">https://discourse.llvm.org/t/rfc-upstreaming-clangir/76587</div></a>
</div>
<div id="ref-clang-lifetime-annotations" class="csl-entry" role="doc-biblioentry">
[clang-lifetime-annotations] Lifetime annotations for the C++ Clang
Frontend. <a href="https://discourse.llvm.org/t/rfc-lifetime-annotations-for-c/61377"><div class="csl-block">https://discourse.llvm.org/t/rfc-lifetime-annotations-for-c/61377</div></a>
</div>
<div id="ref-clone-trait" class="csl-entry" role="doc-biblioentry">
[clone-trait] Clone in std::clone. <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><div class="csl-block">https://doc.rust-lang.org/std/clone/trait.Clone.html</div></a>
</div>
<div id="ref-copy-trait" class="csl-entry" role="doc-biblioentry">
[copy-trait] Copy in std::marker. <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><div class="csl-block">https://doc.rust-lang.org/std/marker/trait.Copy.html</div></a>
</div>
<div id="ref-cve-rs" class="csl-entry" role="doc-biblioentry">
[cve-rs] cve-rs. <a href="https://github.com/Speykious/cve-rs"><div class="csl-block">https://github.com/Speykious/cve-rs</div></a>
</div>
<div id="ref-drop" class="csl-entry" role="doc-biblioentry">
[drop] drop in std::ops. <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><div class="csl-block">https://doc.rust-lang.org/std/ops/trait.Drop.html</div></a>
</div>
<div id="ref-gen-kill" class="csl-entry" role="doc-biblioentry">
[gen-kill] Data-flow analysis. <a href="https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems"><div class="csl-block">https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems</div></a>
</div>
<div id="ref-google-0day" class="csl-entry" role="doc-biblioentry">
[google-0day] 0day <span>“In the Wild.”</span> <a href="https://googleprojectzero.blogspot.com/p/0day.html"><div class="csl-block">https://googleprojectzero.blogspot.com/p/0day.html</div></a>
</div>
<div id="ref-hoare" class="csl-entry" role="doc-biblioentry">
[hoare] Null References: The Billion Dollar Mistake. <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/"><div class="csl-block">https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/</div></a>
</div>
<div id="ref-how-the-borrow-check-works" class="csl-entry" role="doc-biblioentry">
[how-the-borrow-check-works] How the borrow check works. <a href="https://rust-lang.github.io/rfcs/2094-nll.html#layer-5-how-the-borrow-check-works"><div class="csl-block">https://rust-lang.github.io/rfcs/2094-nll.html#layer-5-how-the-borrow-check-works</div></a>
</div>
<div id="ref-isprint" class="csl-entry" role="doc-biblioentry">
[isprint] std::isprint. <a href="https://en.cppreference.com/w/cpp/string/byte/isprint"><div class="csl-block">https://en.cppreference.com/w/cpp/string/byte/isprint</div></a>
</div>
<div id="ref-itanium-abi" class="csl-entry" role="doc-biblioentry">
[itanium-abi] Itanium C++ ABI: Non-Trivial Parameters. <a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#non-trivial-parameters"><div class="csl-block">https://itanium-cxx-abi.github.io/cxx-abi/abi.html#non-trivial-parameters</div></a>
</div>
<div id="ref-matches" class="csl-entry" role="doc-biblioentry">
[matches] matches! macro. <a href="https://doc.rust-lang.org/std/macro.matches.html"><div class="csl-block">https://doc.rust-lang.org/std/macro.matches.html</div></a>
</div>
<div id="ref-may-dangle" class="csl-entry" role="doc-biblioentry">
[may-dangle] dropck_eyepatch. <a href="https://rust-lang.github.io/rfcs/1327-dropck-param-eyepatch.html"><div class="csl-block">https://rust-lang.github.io/rfcs/1327-dropck-param-eyepatch.html</div></a>
</div>
<div id="ref-mir" class="csl-entry" role="doc-biblioentry">
[mir] The MIR (Mid-level IR). <a href="https://rustc-dev-guide.rust-lang.org/mir/index.html"><div class="csl-block">https://rustc-dev-guide.rust-lang.org/mir/index.html</div></a>
</div>
<div id="ref-ms-vulnerabilities" class="csl-entry" role="doc-biblioentry">
[ms-vulnerabilities] We need a safer systems programming language. <a href="https://msrc.microsoft.com/blog/2019/07/we-need-a-safer-systems-programming-language"><div class="csl-block">https://msrc.microsoft.com/blog/2019/07/we-need-a-safer-systems-programming-language</div></a>
</div>
<div id="ref-mutex" class="csl-entry" role="doc-biblioentry">
[mutex] Mutex. <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><div class="csl-block">https://doc.rust-lang.org/std/sync/struct.Mutex.html</div></a>
</div>
<div id="ref-ncsi-plan" class="csl-entry" role="doc-biblioentry">
[ncsi-plan] National Cybersecurity Strategy Implementation Plan. <a href="https://www.whitehouse.gov/wp-content/uploads/2024/05/NCSIP-Version-2-FINAL-May-2024.pdf"><div class="csl-block">https://www.whitehouse.gov/wp-content/uploads/2024/05/NCSIP-Version-2-FINAL-May-2024.pdf</div></a>
</div>
<div id="ref-nsa-guidance" class="csl-entry" role="doc-biblioentry">
[nsa-guidance] NSA Releases Guidance on How to Protect Against Software
Memory Safety Issues. <a href="https://www.nsa.gov/Press-Room/News-Highlights/Article/Article/3215760/nsa-releases-guidance-on-how-to-protect-against-software-memory-safety-issues/"><div class="csl-block">https://www.nsa.gov/Press-Room/News-Highlights/Article/Article/3215760/nsa-releases-guidance-on-how-to-protect-against-software-memory-safety-issues/</div></a>
</div>
<div id="ref-P1179R1" class="csl-entry" role="doc-biblioentry">
[P1179R1] Herb Sutter. 2019-11-22. Lifetime safety: Preventing common
dangling. <a href="https://wg21.link/p1179r1"><div class="csl-block">https://wg21.link/p1179r1</div></a>
</div>
<div id="ref-P2688R1" class="csl-entry" role="doc-biblioentry">
[P2688R1] Michael Park. 2024-02-15. Pattern Matching: `match`
Expression. <a href="https://wg21.link/p2688r1"><div class="csl-block">https://wg21.link/p2688r1</div></a>
</div>
<div id="ref-P3166R0" class="csl-entry" role="doc-biblioentry">
[P3166R0] Lewis Baker. 2024-03-16. Static Exception Specifications. <a href="https://wg21.link/p3166r0"><div class="csl-block">https://wg21.link/p3166r0</div></a>
</div>
<div id="ref-phantom-data" class="csl-entry" role="doc-biblioentry">
[phantom-data] PhantomData. <a href="https://doc.rust-lang.org/nomicon/phantom-data.html"><div class="csl-block">https://doc.rust-lang.org/nomicon/phantom-data.html</div></a>
</div>
<div id="ref-pin" class="csl-entry" role="doc-biblioentry">
[pin] Module std::pin. <a href="https://doc.rust-lang.org/std/pin/index.html"><div class="csl-block">https://doc.rust-lang.org/std/pin/index.html</div></a>
</div>
<div id="ref-raii" class="csl-entry" role="doc-biblioentry">
[raii] Resource acquisition is initialization. <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization"><div class="csl-block">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</div></a>
</div>
<div id="ref-ref-cell" class="csl-entry" role="doc-biblioentry">
[ref-cell] RefCell. <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><div class="csl-block">https://doc.rust-lang.org/std/cell/struct.RefCell.html</div></a>
</div>
<div id="ref-russinovich" class="csl-entry" role="doc-biblioentry">
[russinovich] It’s time to start halting any new projects in C/C++ and
use Rust. <a href="https://x.com/markrussinovich/status/1571995117233504257?lang=en"><div class="csl-block">https://x.com/markrussinovich/status/1571995117233504257?lang=en</div></a>
</div>
<div id="ref-rust-iterator" class="csl-entry" role="doc-biblioentry">
[rust-iterator] Iterator in std::iter. <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><div class="csl-block">https://doc.rust-lang.org/std/iter/trait.Iterator.html</div></a>
</div>
<div id="ref-rust-language" class="csl-entry" role="doc-biblioentry">
[rust-language] The Rust Programming Language. <a href="https://doc.rust-lang.org/book/"><div class="csl-block">https://doc.rust-lang.org/book/</div></a>
</div>
<div id="ref-rwlock" class="csl-entry" role="doc-biblioentry">
[rwlock] RwLock. <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><div class="csl-block">https://doc.rust-lang.org/std/sync/struct.RwLock.html</div></a>
</div>
<div id="ref-safety-comments" class="csl-entry" role="doc-biblioentry">
[safety-comments] Safety comments policy. <a href="https://std-dev-guide.rust-lang.org/policy/safety-comments.html"><div class="csl-block">https://std-dev-guide.rust-lang.org/policy/safety-comments.html</div></a>
</div>
<div id="ref-safe-unsafe-meaning" class="csl-entry" role="doc-biblioentry">
[safe-unsafe-meaning] How Safe and Unsafe Interact. <a href="https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html"><div class="csl-block">https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html</div></a>
</div>
<div id="ref-scc" class="csl-entry" role="doc-biblioentry">
[scc] Strongly connected component. <a href="https://en.wikipedia.org/wiki/Strongly_connected_component"><div class="csl-block">https://en.wikipedia.org/wiki/Strongly_connected_component</div></a>
</div>
<div id="ref-secure-by-design" class="csl-entry" role="doc-biblioentry">
[secure-by-design] Secure by Design : Google’s Perspective on Memory
Safety. <a href="https://research.google/pubs/secure-by-design-googles-perspective-on-memory-safety/"><div class="csl-block">https://research.google/pubs/secure-by-design-googles-perspective-on-memory-safety/</div></a>
</div>
<div id="ref-sil" class="csl-entry" role="doc-biblioentry">
[sil] Swift Intermediate Language (SIL). <a href="https://github.com/swiftlang/swift/blob/main/docs/SIL.rst"><div class="csl-block">https://github.com/swiftlang/swift/blob/main/docs/SIL.rst</div></a>
</div>
<div id="ref-string-view-use-after-free" class="csl-entry" role="doc-biblioentry">
[string-view-use-after-free] std::string_view encourages use-after-free;
the Core Guidelines Checker doesn’t complain. <a href="https://github.com/isocpp/CppCoreGuidelines/issues/1038"><div class="csl-block">https://github.com/isocpp/CppCoreGuidelines/issues/1038</div></a>
</div>
<div id="ref-taming-the-wildcards" class="csl-entry" role="doc-biblioentry">
[taming-the-wildcards] Taming the Wildcards: Combining Definition- and
Use-Site Variance. <a href="https://yanniss.github.io/variance-pldi11.pdf"><div class="csl-block">https://yanniss.github.io/variance-pldi11.pdf</div></a>
</div>
<div id="ref-tracing-gc" class="csl-entry" role="doc-biblioentry">
[tracing-gc] Tracing garbage collection. <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection"><div class="csl-block">https://en.wikipedia.org/wiki/Tracing_garbage_collection</div></a>
</div>
<div id="ref-unsafe-cell" class="csl-entry" role="doc-biblioentry">
[unsafe-cell] UnsafeCell. <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"><div class="csl-block">https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html</div></a>
</div>
<div id="ref-unwinding-puts-limits-on-the-borrow-checker" class="csl-entry" role="doc-biblioentry">
[unwinding-puts-limits-on-the-borrow-checker] Unwinding puts limits on
the borrow checker. <a href="https://smallcultfollowing.com/babysteps/blog/2024/05/02/unwind-considered-harmful/#unwinding-puts-limits-on-the-borrow-checker"><div class="csl-block">https://smallcultfollowing.com/babysteps/blog/2024/05/02/unwind-considered-harmful/#unwinding-puts-limits-on-the-borrow-checker</div></a>
</div>
<div id="ref-variance" class="csl-entry" role="doc-biblioentry">
[variance] RFC 0738 - variance. <a href="https://rust-lang.github.io/rfcs/0738-variance.html"><div class="csl-block">https://rust-lang.github.io/rfcs/0738-variance.html</div></a>
</div>
<div id="ref-vocabulary-types" class="csl-entry" role="doc-biblioentry">
[vocabulary-types] CXX — safe interop between Rust and C++. <a href="https://cxx.rs/bindings.html"><div class="csl-block">https://cxx.rs/bindings.html</div></a>
</div>
<div id="ref-white-house" class="csl-entry" role="doc-biblioentry">
[white-house] Future Software Should Be Memory Safe. <a href="https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/"><div class="csl-block">https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/</div></a>
</div>
</div>
</div>
</div>
</body>
</html>
